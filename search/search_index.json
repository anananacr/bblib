{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to the beambusters library documentation!"},{"location":"reference/","title":"About bblib","text":"<p>The beambusters library (bblib) is a library that contains methods to determine the detector center directly from still diffraction patterns collected in serial crystallography experiments.</p> <p>You can find more information about beambusters on this page.</p>"},{"location":"reference/contact/","title":"Contact","text":"<p>Ana Carolina Rodrigues led the development of bblib from 2021 to 2025 at the Deutsches Elektronen-Synchrotron (DESY) in Hamburg, Germany.</p> <p>For questions, please contact:</p> <p>Email: sc.anarodrigues@gmail.com</p>"},{"location":"reference/install/","title":"Installation","text":"<p>To install bblib, run the following command in a terminal:</p> <pre><code>pip install bblib\n</code></pre>"},{"location":"reference/methods/","title":"Methods","text":"<p>               Bases: <code>ABC</code></p> <p>This class defines the structure of a centering method used to determine the center of diffraction patterns.</p> Source code in <code>bblib/methods.py</code> <pre><code>class CenteringMethod(ABC):\n    \"\"\"\n    This class defines the structure of a centering method used to determine the center of diffraction patterns.\n\n    \"\"\"\n\n    @abstractmethod\n    def __init__(self, **kwargs) -&gt; None: ...\n\n    @abstractmethod\n    def _prep_for_centering(self, **kwargs) -&gt; None: ...\n\n    @abstractmethod\n    def _run_centering(self) -&gt; tuple: ...\n\n    def __call__(self, **kwargs) -&gt; tuple:\n        self._prep_for_centering(**kwargs)\n        return self._run_centering()\n\n    def centering_converged(self, center) -&gt; bool:\n        if center == [-1, -1]:\n            return False\n        else:\n            return True\n</code></pre> <p>               Bases: <code>CenteringMethod</code></p> <p>This class determine the center of a diffraction pattern by calculating the center of mass of the image.</p> Source code in <code>bblib/methods.py</code> <pre><code>class CenterOfMass(CenteringMethod):\n    \"\"\"\n    This class determine the center of a diffraction pattern by calculating the center of mass of the image.\n\n    \"\"\"\n\n    def __init__(self, config: dict, PF8Config: PF8Info, plots_info: dict = None):\n        \"\"\"\n        This method initializes the CenterOfMass centering method.\n\n        Args:\n            config (dict): A configuration dictionary in a format expected by beambusters.\n            PF8Config (PF8Info): Peakfinder8 parameters.\n            plots_info (dict): Configuration parameters to generate plots.\n        \"\"\"\n\n        self.config = config\n        self.PF8Config = PF8Config\n        self.plots_info = plots_info\n\n        if config[\"plots_flag\"] and not plots_info:\n            raise ValueError(\n                \"From config you want to save plots, please indicate the information to save the plots.\"\n            )\n\n        # Creates an empty plots_info dictionary.\n        if not config[\"plots_flag\"] and not plots_info:\n            plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n\n    def _prep_for_centering(self, data: np.ndarray):\n\n        self.initial_detector_center = self.PF8Config.get_detector_center()\n        # Determine Bragg peaks position.\n        pf8 = PF8(self.PF8Config)\n        peak_list = pf8.get_peaks_pf8(data=data)\n        peak_list_x_in_frame, peak_list_y_in_frame = pf8.peak_list_in_slab(peak_list)\n        row_indexes = np.zeros(peak_list[\"num_peaks\"], dtype=int)\n        col_indexes = np.zeros(peak_list[\"num_peaks\"], dtype=int)\n\n        # Calculate the peaks index in the data array.\n        for idx, k in enumerate(peak_list_y_in_frame):\n            row_peak = int(k + self.initial_detector_center[1])\n            col_peak = int(peak_list_x_in_frame[idx] + self.initial_detector_center[0])\n            row_indexes[idx] = row_peak\n            col_indexes[idx] = col_peak\n        peaks_indexes = (row_indexes, col_indexes)\n\n        # Assemble data and mask\n        data_visualize = geometry.DataVisualizer(pixel_maps=self.PF8Config.pixel_maps)\n\n        with h5py.File(f\"{self.PF8Config.bad_pixel_map_filename}\", \"r\") as f:\n            mask = np.array(f[f\"{self.PF8Config.bad_pixel_map_hdf5_path}\"])\n\n        if (\n            self.PF8Config.pf8_detector_info[\"nasics_x\"]\n            * self.PF8Config.pf8_detector_info[\"nasics_y\"]\n            &gt; 1\n        ):\n            self.visual_data = data_visualize.visualize_data(data=data)\n            visual_mask = data_visualize.visualize_data(data=mask).astype(int)\n        else:\n\n            self.visual_data = visualize_single_panel(\n                data, self.PF8Config.transformation_matrix_for_visualization, self.PF8Config.ss_in_rows\n            )\n            visual_mask = visualize_single_panel(\n                mask, self.PF8Config.transformation_matrix_for_visualization, self.PF8Config.ss_in_rows\n            )\n\n        # JF for safety\n        visual_mask[np.where(self.visual_data &lt; 0)] = 0\n\n        # Mask Bragg peaks\n        peaks_mask = mask_peaks(\n            visual_mask,\n            peaks_indexes,\n            bragg=self.config[\"bragg_peaks_for_center_of_mass_calculation\"],\n            n=self.config[\"pixels_for_mask_of_bragg_peaks\"],\n        )\n        self.mask_for_center_of_mass = peaks_mask * visual_mask\n\n    def _run_centering(self) -&gt; tuple:\n\n        center = center_of_mass(self.visual_data, self.mask_for_center_of_mass)\n\n        if self.config[\"plots_flag\"]:\n            visual_img = self.visual_data * self.mask_for_center_of_mass\n            fig, ax1 = plt.subplots(1, 1, figsize=(10, 10))\n            if self.plots_info[\"value_auto\"]:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                pos = ax1.imshow(\n                    visual_img, norm=LogNorm(), cmap=color_map, origin=\"lower\"\n                )\n            else:\n\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                if self.plots_info[\"value_min\"] &lt;= 0:\n                    self.plots_info[\"value_min\"] = 1\n                pos = ax1.imshow(\n                    visual_img,\n                    norm=LogNorm(\n                        self.plots_info[\"value_min\"], self.plots_info[\"value_max\"]\n                    ),\n                    cmap=color_map,\n                    origin=\"lower\",\n                )\n            if not \"marker_size\" in self.plots_info:\n                self.plots_info[\"marker_size\"] = 20\n            ax1.scatter(\n                int(self.initial_detector_center[0]),\n                int(self.initial_detector_center[1]),\n                s=self.plots_info[\"marker_size\"],\n                color=\"blue\",\n                marker=\"o\",\n                edgecolor=\"black\",\n                linewidth=0.5,\n                label=f\"Initial detector center: ({round(self.initial_detector_center[0],1)}, {round(self.initial_detector_center[1],1)})\",\n            )\n            ax1.scatter(\n                int(center[0]),\n                int(center[1]),\n                s=self.plots_info[\"marker_size\"],\n                color=\"r\",\n                marker=\"^\",\n                edgecolor=\"black\",\n                linewidth=0.5,\n                label=f\"Refined detector center: ({round(center[0],1)}, {round(center[1],1)})\",\n            )\n            ax1.legend(fontsize=14, loc=1, markerscale=1)\n            plt.tick_params(axis=\"both\", which=\"major\", labelsize=16)\n            ax1.set_xlabel(\"x (pixel)\", fontsize=20)\n            ax1.set_ylabel(\"y (pixel)\", fontsize=20)\n\n            cbar = fig.colorbar(pos, ax=ax1, shrink=0.6)\n            cbar.ax.tick_params(labelsize=20)\n\n            path = pathlib.Path(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/center_of_mass/'\n            )\n            path.mkdir(parents=True, exist_ok=True)\n            if not self.plots_info[\"axis_lim_auto\"]:\n                ax1.set_xlim(self.plots_info[\"xlim_min\"], self.plots_info[\"xlim_max\"])\n                ax1.set_ylim(self.plots_info[\"ylim_min\"], self.plots_info[\"ylim_max\"])\n            plt.savefig(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/center_of_mass/{self.plots_info[\"filename\"]}.png'\n            )\n            plt.close()\n\n        return center\n</code></pre> <p>               Bases: <code>CenteringMethod</code></p> <p>This class determines the center of a diffraction pattern as the center of a circle contained in the image.</p> Source code in <code>bblib/methods.py</code> <pre><code>class CircleDetection(CenteringMethod):\n    \"\"\"\n    This class determines the center of a diffraction pattern as the center of a circle contained in the image.\n    \"\"\"\n\n    def __init__(self, config: dict, PF8Config: PF8Info, plots_info: dict = None):\n        \"\"\"\n        This method initializes the CircleDetection centering method.\n\n        Args:\n            config (dict): A configuration dictionary in a format expected by beambusters.\n            PF8Config (PF8Info): Peakfinder8 parameters.\n            plots_info (dict): Configuration parameters to generate plots.\n        \"\"\"\n        self.config = config\n        self.PF8Config = PF8Config\n        self.plots_info = plots_info\n        if config[\"plots_flag\"] and not plots_info:\n            raise ValueError(\n                \"From config you want to save plots, please indicate the information to save the plots.\"\n            )\n\n        if not config[\"plots_flag\"] and not plots_info:\n            plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n\n    def _prep_for_centering(self, data: np.ndarray) -&gt; None:\n        self.initial_detector_center = self.PF8Config.get_detector_center()\n        ## Find peaks\n        pf8 = PF8(self.PF8Config)\n        peak_list = pf8.get_peaks_pf8(data=data)\n        peak_list_x_in_frame, peak_list_y_in_frame = pf8.peak_list_in_slab(peak_list)\n        row_indexes = np.zeros(peak_list[\"num_peaks\"], dtype=int)\n        col_indexes = np.zeros(peak_list[\"num_peaks\"], dtype=int)\n\n        for idx, k in enumerate(peak_list_y_in_frame):\n            row_peak = int(k + self.initial_detector_center[1])\n            col_peak = int(peak_list_x_in_frame[idx] + self.initial_detector_center[0])\n            row_indexes[idx] = row_peak\n            col_indexes[idx] = col_peak\n        peaks_indexes = (row_indexes, col_indexes)\n\n        # Assemble data and mask\n        data_visualize = geometry.DataVisualizer(pixel_maps=self.PF8Config.pixel_maps)\n\n        with h5py.File(f\"{self.PF8Config.bad_pixel_map_filename}\", \"r\") as f:\n            mask = np.array(f[f\"{self.PF8Config.bad_pixel_map_hdf5_path}\"])\n\n        if (\n            self.PF8Config.pf8_detector_info[\"nasics_x\"]\n            * self.PF8Config.pf8_detector_info[\"nasics_y\"]\n            &gt; 1\n        ):\n            self.visual_data = data_visualize.visualize_data(data=data)\n            visual_mask = data_visualize.visualize_data(data=mask).astype(int)\n        else:\n\n            self.visual_data = visualize_single_panel(\n                data, self.PF8Config.transformation_matrix_for_visualization, self.PF8Config.ss_in_rows\n            )\n            visual_mask = visualize_single_panel(\n                mask, self.PF8Config.transformation_matrix_for_visualization, self.PF8Config.ss_in_rows\n            )\n\n        # JF for safety\n        visual_mask[np.where(self.visual_data &lt; 0)] = 0\n        only_peaks_mask = mask_peaks(\n            visual_mask,\n            peaks_indexes,\n            bragg=0,\n            n=self.config[\"pixels_for_mask_of_bragg_peaks\"],\n        )\n        self.mask_for_circle_detection = only_peaks_mask * visual_mask\n\n    def _run_centering(self, **kwargs) -&gt; tuple:\n        ## Scikit-image circle detection\n        edges = canny(\n            self.visual_data,\n            mask=self.mask_for_circle_detection,\n            sigma=self.config[\"canny\"][\"sigma\"],\n            use_quantiles=True,\n            low_threshold=self.config[\"canny\"][\"low_threshold\"],\n            high_threshold=self.config[\"canny\"][\"high_threshold\"],\n        )\n\n        if self.config[\"plots_flag\"]:\n            fig, ax1 = plt.subplots(1, 1, figsize=(10, 10))\n            color_map = copy.copy(matplotlib.colormaps[self.plots_info[\"color_map\"]])\n            color_map.set_bad(color_map(0))\n            pos = ax1.imshow(edges, origin=\"lower\", cmap=color_map)\n            plt.tick_params(axis=\"both\", which=\"major\", labelsize=16)\n            ax1.set_xlabel(\"x (pixel)\", fontsize=20)\n            ax1.set_ylabel(\"y (pixel)\", fontsize=20)\n            cbar = fig.colorbar(pos, ax=ax1, shrink=0.6)\n            cbar.ax.tick_params(labelsize=20)\n\n            path = pathlib.Path(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/edges/'\n            )\n            path.mkdir(parents=True, exist_ok=True)\n            plt.savefig(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/edges/{self.plots_info[\"filename\"]}.png'\n            )\n            plt.close()\n        # Detect radii\n        hough_radii = np.arange(\n            self.config[\"peak_region\"][\"min\"], self.config[\"peak_region\"][\"max\"], 1\n        )\n        hough_res = hough_circle(edges, hough_radii)\n        # Select the most prominent circle given the hough_rank chosen\n        accums, xc, yc, radii = hough_circle_peaks(\n            hough_res, hough_radii, total_num_peaks=int(self.config[\"hough_rank\"])\n        )\n\n        if len(xc) &gt; 0:\n            xc = xc[int(self.config[\"hough_rank\"] - 1)]\n            yc = yc[int(self.config[\"hough_rank\"] - 1)]\n        else:\n            xc = -1\n            yc = -1\n\n        center = [xc, yc]\n        if self.config[\"plots_flag\"]:\n            visual_img = self.visual_data * self.mask_for_circle_detection\n            fig, ax1 = plt.subplots(1, 1, figsize=(10, 10))\n            if self.plots_info[\"value_auto\"]:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                pos = ax1.imshow(\n                    visual_img,\n                    norm=LogNorm(),\n                    origin=\"lower\",\n                    cmap=color_map,\n                )\n            else:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                if self.plots_info[\"value_min\"] &lt;= 0:\n                    self.plots_info[\"value_min\"] = 1\n                pos = ax1.imshow(\n                    visual_img,\n                    norm=LogNorm(\n                        self.plots_info[\"value_min\"], self.plots_info[\"value_max\"]\n                    ),\n                    origin=\"lower\",\n                    cmap=color_map,\n                )\n            if not \"marker_size\" in self.plots_info:\n                self.plots_info[\"marker_size\"] = 20\n            ax1.scatter(\n                int(self.initial_detector_center[0]),\n                int(self.initial_detector_center[1]),\n                s=self.plots_info[\"marker_size\"],\n                color=\"blue\",\n                marker=\"o\",\n                edgecolor=\"black\",\n                linewidth=0.5,\n                label=f\"Initial detector center: ({round(self.initial_detector_center[0],1)}, {round(self.initial_detector_center[1],1)})\",\n            )\n            ax1.scatter(\n                int(center[0]),\n                int(center[1]),\n                s=self.plots_info[\"marker_size\"],\n                color=\"r\",\n                marker=\"^\",\n                edgecolor=\"black\",\n                linewidth=0.5,\n                label=f\"Refined detector center: ({center[0]}, {center[1]})\",\n            )\n            path = pathlib.Path(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/center_circle_detection/'\n            )\n            path.mkdir(parents=True, exist_ok=True)\n            ax1.legend(fontsize=14, loc=1, markerscale=1)\n            cbar = fig.colorbar(pos, ax=ax1, shrink=0.6)\n            cbar.ax.tick_params(labelsize=20)\n            plt.tick_params(axis=\"both\", which=\"major\", labelsize=16)\n            ax1.set_xlabel(\"x (pixel)\", fontsize=20)\n            ax1.set_ylabel(\"y (pixel)\", fontsize=20)\n\n            if not self.plots_info[\"axis_lim_auto\"]:\n                ax1.set_xlim(self.plots_info[\"xlim_min\"], self.plots_info[\"xlim_max\"])\n                ax1.set_ylim(self.plots_info[\"ylim_min\"], self.plots_info[\"ylim_max\"])\n            plt.savefig(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/center_circle_detection/{self.plots_info[\"filename\"]}.png'\n            )\n            plt.close()\n        return center\n</code></pre> <p>               Bases: <code>CenteringMethod</code></p> <p>This class determines the center of a diffraction pattern by minimizing the FWHM of a Gaussian curve fitted to an interval in the azimuthal integration.</p> Source code in <code>bblib/methods.py</code> <pre><code>class MinimizePeakFWHM(CenteringMethod):\n    \"\"\"\n    This class determines the center of a diffraction pattern by minimizing the FWHM of a Gaussian curve fitted to an interval in the azimuthal integration.\n    \"\"\"\n\n    def __init__(self, config: dict, PF8Config: PF8Info, plots_info: dict = None):\n        \"\"\"\n        This method initializes the MinimizePeakFWHM centering method.\n\n        Args:\n            config (dict): A configuration dictionary in a format expected by beambusters.\n            PF8Config (PF8Info): Peakfinder8 parameters.\n            plots_info (dict): Configuration parameters to generate plots.\n        \"\"\"\n        self.config = config\n        self.PF8Config = PF8Config\n        self.plots_info = plots_info\n        self.plot_fwhm_flag = False\n        if config[\"plots_flag\"] and not plots_info:\n            raise ValueError(\n                \"From config you want to save plots, please indicate the information to save the plots.\"\n            )\n\n        if not config[\"plots_flag\"] and not plots_info:\n            plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n\n    def _calculate_fwhm(self, coordinate: tuple) -&gt; dict:\n        center_to_radial_average = coordinate\n        try:\n            x_all, y_all = azimuthal_average_fast(\n                self.visual_data,\n                center=center_to_radial_average,\n                mask=self.mask_for_fwhm_min,\n            )\n        except IndexError:\n            return {\n                \"xc\": center_to_radial_average[0],\n                \"yc\": center_to_radial_average[1],\n                \"fwhm\": 10000,\n                \"r_square\": 0,\n            }\n\n        if self.plot_fwhm_flag:\n            fig, ax1 = plt.subplots(1, 1, figsize=(8, 8))\n            plt.plot(x_all, y_all)\n            ax1.set_xlabel(\"Radial distance (pixel)\", fontsize=20)\n            ax1.set_ylabel(\"Intensity (ADU)\", fontsize=20)\n            plt.tick_params(axis=\"both\", which=\"major\", labelsize=16)\n\n        ## Define background peak region\n        x_min = self.config[\"peak_region\"][\"min\"]\n        x_max = self.config[\"peak_region\"][\"max\"]\n        x = x_all[x_min:x_max]\n        y = y_all[x_min:x_max]\n        ## Estimation of initial parameters\n\n        m0 = 0\n        n0 = 2\n        y_linear = m0 * x + n0\n        y_gaussian = y - y_linear\n\n        try:\n            mean = sum(x * y_gaussian) / sum(y_gaussian)\n            sigma = np.sqrt(sum(y_gaussian * (x - mean) ** 2) / sum(y_gaussian))\n            popt, pcov = curve_fit(\n                gaussian_lin, x, y, p0=[max(y_gaussian), mean, sigma, m0, n0]\n            )\n            fwhm = popt[2] * math.sqrt(8 * np.log(2))\n\n            ##Calculate residues\n            residuals = y - gaussian_lin(x, *popt)\n            ss_res = np.sum(residuals**2)\n            ss_tot = np.sum((y - np.mean(y)) ** 2)\n            r_square = 1 - (ss_res / ss_tot)\n        except (ZeroDivisionError, RuntimeError):\n            r_square = 0\n            fwhm = 10000\n            popt = []\n\n        ## Display plots\n        if self.plot_fwhm_flag and len(popt) &gt; 0:\n            x_fit = x.copy()\n            y_fit = gaussian_lin(x_fit, *popt)\n\n            plt.vlines([x[0], x[-1]], 0, np.max(y) * 1.5, \"r\")\n\n            plt.plot(\n                x_fit,\n                y_fit,\n                \"r--\",\n                label=f\"gaussian fit \\n a:{round(popt[0],2)} \\n x0:{round(popt[1],2)} \\n sigma:{round(popt[2],2)} \\n R\u00b2 {round(r_square, 4)}\\n FWHM : {round(fwhm,3)}\",\n            )\n\n            plt.legend(fontsize=14, loc=1, markerscale=1)\n            path = pathlib.Path(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/radial_average/'\n            )\n            path.mkdir(parents=True, exist_ok=True)\n            plt.savefig(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/radial_average/{self.plots_info[\"filename\"]}.png'\n            )\n            plt.close()\n\n        return {\n            \"xc\": center_to_radial_average[0],\n            \"yc\": center_to_radial_average[1],\n            \"fwhm\": fwhm,\n            \"r_square\": r_square,\n        }\n\n    def _prep_for_centering(self, data: np.ndarray, initial_guess: tuple) -&gt; None:\n        self.initial_guess = initial_guess\n        self.initial_detector_center = self.PF8Config.get_detector_center()\n        non_shifted_pixel_maps_for_visualization = self.PF8Config.pixel_maps.copy()\n        ## Find peaks\n        self.PF8Config.update_pixel_maps(\n            initial_guess[0] - self.initial_detector_center[0],\n            initial_guess[1] - self.initial_detector_center[1],\n        )\n        pf8 = PF8(self.PF8Config)\n        # Assemble data and mask\n        data_visualize = geometry.DataVisualizer(\n            pixel_maps=non_shifted_pixel_maps_for_visualization\n        )\n\n        with h5py.File(f\"{self.PF8Config.bad_pixel_map_filename}\", \"r\") as f:\n            mask = np.array(f[f\"{self.PF8Config.bad_pixel_map_hdf5_path}\"])\n\n        if not self.config[\"polarization\"][\"apply_polarization_correction\"]:\n            peak_list = pf8.get_peaks_pf8(data=data)\n            if (\n                self.PF8Config.pf8_detector_info[\"nasics_x\"]\n                * self.PF8Config.pf8_detector_info[\"nasics_y\"]\n                &gt; 1\n            ):\n                self.visual_data = data_visualize.visualize_data(data=data)\n                visual_mask = data_visualize.visualize_data(data=mask).astype(int)\n            else:\n                self.visual_data = visualize_single_panel(\n                    data,\n                    self.PF8Config.transformation_matrix_for_visualization,\n                    self.PF8Config.ss_in_rows,\n                )\n                visual_mask = visualize_single_panel(\n                    mask,\n                    self.PF8Config.transformation_matrix_for_visualization,\n                    self.PF8Config.ss_in_rows,\n                )\n        else:\n            pol_corrected_data, pol_array_map = correct_polarization(\n                self.PF8Config.pixel_maps[\"x\"],\n                self.PF8Config.pixel_maps[\"y\"],\n                float(\n                    np.mean(self.PF8Config.pixel_maps[\"z\"])\n                    * self.PF8Config.pixel_resolution\n                ),\n                data,\n                mask=mask,\n                polarization_axis=self.config[\"polarization\"][\"axis\"],\n                p=self.config[\"polarization\"][\"value\"],\n            )\n            peak_list = pf8.get_peaks_pf8(data=pol_corrected_data)\n            if (\n                self.PF8Config.pf8_detector_info[\"nasics_x\"]\n                * self.PF8Config.pf8_detector_info[\"nasics_y\"]\n                &gt; 1\n            ):\n                self.visual_data = data_visualize.visualize_data(\n                    data=pol_corrected_data\n                )\n                visual_mask = data_visualize.visualize_data(data=mask).astype(int)\n            else:\n                self.visual_data = visualize_single_panel(\n                    pol_corrected_data,\n                    self.PF8Config.transformation_matrix_for_visualization,\n                    self.PF8Config.ss_in_rows,\n                )\n                visual_mask = visualize_single_panel(\n                    mask,\n                    self.PF8Config.transformation_matrix_for_visualization,\n                    self.PF8Config.ss_in_rows,\n                )\n\n        peak_list_x_in_frame, peak_list_y_in_frame = pf8.peak_list_in_slab(peak_list)\n        row_indexes = np.zeros(peak_list[\"num_peaks\"], dtype=int)\n        col_indexes = np.zeros(peak_list[\"num_peaks\"], dtype=int)\n\n        for idx, k in enumerate(peak_list_y_in_frame):\n            row_peak = int(k + self.initial_guess[1])\n            col_peak = int(peak_list_x_in_frame[idx] + self.initial_guess[0])\n            row_indexes[idx] = row_peak\n            col_indexes[idx] = col_peak\n        peaks_indexes = (row_indexes, col_indexes)\n\n        # JF for safety\n        visual_mask[np.where(self.visual_data &lt; 0)] = 0\n\n        only_peaks_mask = mask_peaks(\n            visual_mask,\n            peaks_indexes,\n            bragg=0,\n            n=self.config[\"pixels_for_mask_of_bragg_peaks\"],\n        )\n        self.mask_for_fwhm_min = only_peaks_mask * visual_mask\n\n        self.pixel_step = 1\n\n        box_radius = self.config[\"grid_search_radius\"]\n\n        xx, yy = np.meshgrid(\n            np.arange(\n                self.initial_guess[0] - box_radius,\n                self.initial_guess[0] + box_radius + 1,\n                self.pixel_step,\n                dtype=int,\n            ),\n            np.arange(\n                self.initial_guess[1] - box_radius,\n                self.initial_guess[1] + box_radius + 1,\n                self.pixel_step,\n                dtype=int,\n            ),\n        )\n\n        self.fwhm_summary = [\n            self._calculate_fwhm((x, y)) for x, y in zip(xx.ravel(), yy.ravel())\n        ]\n\n    def _run_centering(self, **kwargs) -&gt; tuple:\n        if self.config[\"plots_flag\"]:\n            path = pathlib.Path(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/fwhm_map/'\n            )\n            path.mkdir(parents=True, exist_ok=True)\n\n        xc, yc = get_fwhm_map_min_from_projection(\n            self.fwhm_summary,\n            f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}',\n            f'{self.plots_info[\"filename\"]}',\n            self.pixel_step,\n            self.config[\"plots_flag\"],\n        )\n\n        center = [xc, yc]\n\n        if self.centering_converged(center):\n            self.plot_fwhm_flag = True\n            self._calculate_fwhm(center)\n            self.plot_fwhm_flag = False\n\n        if self.config[\"plots_flag\"]:\n            visual_img = self.visual_data * self.mask_for_fwhm_min\n            fig, ax1 = plt.subplots(1, 1, figsize=(10, 10))\n            if self.plots_info[\"value_auto\"]:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                pos = ax1.imshow(\n                    visual_img,\n                    norm=LogNorm(),\n                    origin=\"lower\",\n                    cmap=color_map,\n                )\n            else:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                if self.plots_info[\"value_min\"] &lt;= 0:\n                    self.plots_info[\"value_min\"] = 1\n                pos = ax1.imshow(\n                    visual_img,\n                    norm=LogNorm(\n                        self.plots_info[\"value_min\"], self.plots_info[\"value_max\"]\n                    ),\n                    origin=\"lower\",\n                    cmap=color_map,\n                )\n            if not \"marker_size\" in self.plots_info:\n                self.plots_info[\"marker_size\"] = 20\n            ax1.scatter(\n                int(self.initial_guess[0]),\n                int(self.initial_guess[1]),\n                s=self.plots_info[\"marker_size\"],\n                color=\"blue\",\n                marker=\"o\",\n                edgecolor=\"black\",\n                linewidth=0.5,\n                label=f\"Initial guess: ({round(self.initial_guess[0],1)}, {round(self.initial_guess[1],1)})\",\n            )\n            ax1.scatter(\n                int(center[0]),\n                int(center[1]),\n                s=self.plots_info[\"marker_size\"],\n                color=\"r\",\n                marker=\"^\",\n                edgecolor=\"black\",\n                linewidth=0.5,\n                label=f\"Refined detector center: ({int(center[0])}, {int(center[1])})\",\n            )\n            path = pathlib.Path(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/center_fwhm_minimization/'\n            )\n            path.mkdir(parents=True, exist_ok=True)\n            ax1.legend(fontsize=14, loc=1, markerscale=1)\n            plt.tick_params(axis=\"both\", which=\"major\", labelsize=16)\n            ax1.set_xlabel(\"x (pixel)\", fontsize=20)\n            ax1.set_ylabel(\"y (pixel)\", fontsize=20)\n\n            cbar = fig.colorbar(pos, ax=ax1, shrink=0.6)\n            cbar.ax.tick_params(labelsize=20)\n\n            if not self.plots_info[\"axis_lim_auto\"]:\n                ax1.set_xlim(self.plots_info[\"xlim_min\"], self.plots_info[\"xlim_max\"])\n                ax1.set_ylim(self.plots_info[\"ylim_min\"], self.plots_info[\"ylim_max\"])\n            plt.savefig(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/center_fwhm_minimization/{self.plots_info[\"filename\"]}.png'\n            )\n            plt.close()\n\n        return center\n</code></pre> <p>               Bases: <code>CenteringMethod</code></p> <p>This class determines the center of a diffraction pattern through the selection of Friedel pairs candidates and matching of their coordinates.</p> Source code in <code>bblib/methods.py</code> <pre><code>class FriedelPairs(CenteringMethod):\n    \"\"\"\n    This class determines the center of a diffraction pattern through the selection of Friedel pairs candidates and matching of their coordinates.\n    \"\"\"\n\n    def __init__(self, config: dict, PF8Config: PF8Info, plots_info: dict = None):\n        \"\"\"\n        This method initializes the FriedelPairs centering method.\n\n        Args:\n            config (dict): A configuration dictionary in a format expected by beambusters.\n            PF8Config (PF8Info): Peakfinder8 parameters.\n            plots_info (dict): Configuration parameters to generate plots.\n        \"\"\"\n        self.config = config\n        self.PF8Config = PF8Config\n        self.plots_info = plots_info\n        if config[\"plots_flag\"] and not plots_info:\n            raise ValueError(\n                \"From config you want to save plots, please indicate the information to save the plots.\"\n            )\n\n        if not config[\"plots_flag\"] and not plots_info:\n            plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n\n    def _select_closest_peaks(self, peaks_list: list, inverted_peaks: list) -&gt; list:\n        pairs_list = []\n        for i in peaks_list:\n            radius = 0.1\n            found_peak = False\n            while not found_peak and radius &lt;= self.config[\"search_radius\"]:\n                found_peak = self._find_a_peak_in_the_surrounding(\n                    i, inverted_peaks, radius\n                )\n                radius += 0.1\n            if found_peak:\n                pairs_list.append((i, found_peak))\n        pairs_list = self._check_paired_reflections(pairs_list)\n        return pairs_list\n\n    def _find_a_peak_in_the_surrounding(\n        self, peak: list, inverted_peaks_list: list, radius: float\n    ) -&gt; list:\n        cut_peaks_list = []\n        cut_peaks_list = [\n            (\n                inverted_peak,\n                math.sqrt(\n                    (peak[0] - inverted_peak[0]) ** 2\n                    + (peak[1] - inverted_peak[1]) ** 2\n                ),\n            )\n            for inverted_peak in inverted_peaks_list\n            if math.sqrt(\n                (peak[0] - inverted_peak[0]) ** 2 + (peak[1] - inverted_peak[1]) ** 2\n            )\n            &lt;= radius\n        ]\n        cut_peaks_list.sort(key=lambda x: x[1])\n\n        if cut_peaks_list == []:\n            return False\n        else:\n            return cut_peaks_list[0][0]\n\n    def _check_paired_reflections(self, pairs_list: list) -&gt; list:\n        # Check if the reversed peak is also on the list\n        filtered_pairs = []\n\n        for original_peak, inverted_peak in pairs_list:\n            inverted_peak_inverted_twice = (\n                -1 * inverted_peak[0],\n                -1 * inverted_peak[1],\n            )\n            original_peak_inverted_twice = (\n                -1 * original_peak[0],\n                -1 * original_peak[1],\n            )\n            inverted_pair = (inverted_peak_inverted_twice, original_peak_inverted_twice)\n            if inverted_pair in pairs_list:\n                filtered_pairs.append((original_peak, inverted_peak))\n\n        return filtered_pairs\n\n    def _prep_for_centering(self, data: np.ndarray, initial_guess: tuple) -&gt; None:\n\n        self.initial_guess = initial_guess\n        self.initial_detector_center = self.PF8Config.get_detector_center()\n        non_shifted_pixel_maps_for_visualization = self.PF8Config.pixel_maps.copy()\n\n        # Find Bragg  peaks\n        self.PF8Config.update_pixel_maps(\n            initial_guess[0] - self.initial_detector_center[0],\n            initial_guess[1] - self.initial_detector_center[1],\n        )\n\n        pf8 = PF8(self.PF8Config)\n\n        # Assemble data and mask\n        data_visualize = geometry.DataVisualizer(\n            pixel_maps=non_shifted_pixel_maps_for_visualization\n        )\n\n        with h5py.File(f\"{self.PF8Config.bad_pixel_map_filename}\", \"r\") as f:\n            mask = np.array(f[f\"{self.PF8Config.bad_pixel_map_hdf5_path}\"])\n\n        if not self.config[\"polarization\"][\"apply_polarization_correction\"]:\n            peak_list = pf8.get_peaks_pf8(data=data)\n            if (\n                self.PF8Config.pf8_detector_info[\"nasics_x\"]\n                * self.PF8Config.pf8_detector_info[\"nasics_y\"]\n                &gt; 1\n            ):\n                self.visual_data = data_visualize.visualize_data(data=data)\n                self.visual_mask = data_visualize.visualize_data(data=mask).astype(int)\n            else:\n                self.visual_data = visualize_single_panel(\n                    data,\n                    self.PF8Config.transformation_matrix_for_visualization,\n                    self.PF8Config.ss_in_rows,\n                )\n                self.visual_mask = visualize_single_panel(\n                    mask,\n                    self.PF8Config.transformation_matrix_for_visualization,\n                    self.PF8Config.ss_in_rows,\n                )\n        else:\n            pol_corrected_data, pol_array_map = correct_polarization(\n                self.PF8Config.pixel_maps[\"x\"],\n                self.PF8Config.pixel_maps[\"y\"],\n                float(\n                    np.mean(self.PF8Config.pixel_maps[\"z\"])\n                    * self.PF8Config.pixel_resolution\n                ),\n                data,\n                mask=mask,\n                polarization_axis=self.config[\"polarization\"][\"axis\"],\n                p=self.config[\"polarization\"][\"value\"],\n            )\n            peak_list = pf8.get_peaks_pf8(data=pol_corrected_data)\n            if (\n                self.PF8Config.pf8_detector_info[\"nasics_x\"]\n                * self.PF8Config.pf8_detector_info[\"nasics_y\"]\n                &gt; 1\n            ):\n                self.visual_data = data_visualize.visualize_data(\n                    data=pol_corrected_data\n                )\n                self.visual_mask = data_visualize.visualize_data(data=mask).astype(int)\n            else:\n                self.visual_data = visualize_single_panel(\n                    pol_corrected_data,\n                    self.PF8Config.transformation_matrix_for_visualization,\n                    self.PF8Config.ss_in_rows,\n                )\n                self.visual_mask = visualize_single_panel(\n                    mask,\n                    self.PF8Config.transformation_matrix_for_visualization,\n                    self.PF8Config.ss_in_rows,\n                )\n\n        peak_list_in_slab = pf8.peak_list_in_slab(peak_list)\n        self.peak_list_x_in_frame, self.peak_list_y_in_frame = peak_list_in_slab\n\n    def _run_centering(self, **kwargs) -&gt; tuple:\n\n        peak_list_x_in_frame = self.peak_list_x_in_frame.copy()\n        peak_list_y_in_frame = self.peak_list_y_in_frame.copy()\n\n        peaks = list(zip(peak_list_x_in_frame, peak_list_y_in_frame))\n        inverted_peaks_x = [-1 * k for k in peak_list_x_in_frame]\n        inverted_peaks_y = [-1 * k for k in peak_list_y_in_frame]\n        inverted_peaks = list(zip(inverted_peaks_x, inverted_peaks_y))\n        pairs_list = self._select_closest_peaks(peaks, inverted_peaks)\n\n        # Calculcate the direct beam shift\n\n        self.peaks_list_original = [x for x, y in pairs_list]\n        self.peaks_list_inverted = [y for x, y in pairs_list]\n\n        if len(pairs_list) &gt; 0:\n            print(\n                f\"--------------  Friedel pairs search --------------\\nNumber of Friedel Pairs in frame: {len(pairs_list)/2}\"\n            )\n            print(f\"Pairs list for analysis:\")\n            print(pairs_list)\n\n            friedel_coordinates_in_x = [x for x, y in self.peaks_list_original]\n            friedel_coordinates_in_y = [y for x, y in self.peaks_list_original]\n\n            print(f\"Friedel pairs position before center correction in pixels:\")\n            print(self.peaks_list_original)\n\n            shift_x = sum(friedel_coordinates_in_x) / len(friedel_coordinates_in_x)\n            shift_y = sum(friedel_coordinates_in_y) / len(friedel_coordinates_in_y)\n\n            print(\"Center shift in x\", shift_x)\n            print(\"Center shift in y\", shift_y)\n            center = [\n                self.initial_guess[0] + shift_x,\n                self.initial_guess[1] + shift_y,\n            ]\n\n            print(\"Friedel pairs position after center correction in pixels:\")\n            pairs_list_after_correction = [\n                (round(x[0] - shift_x, 1), round(x[1] - shift_y, 1))\n                for x in self.peaks_list_original\n            ]\n            print(pairs_list_after_correction)\n            print(\"All reflections after center correction in pixels:\")\n            peaks_list_after_correction = [\n                (round(x[0] - shift_x, 1), round(x[1] - shift_y, 1))\n                for x in peaks\n            ]\n            print(peaks_list_after_correction)\n            print(\"-- End --\")\n\n        else:\n            center = [-1, -1]\n\n        if self.config[\"plots_flag\"] and self.centering_converged(center):\n\n            fig, ax1 = plt.subplots(1, 1, figsize=(10, 10))\n            if self.plots_info[\"value_auto\"]:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                pos = ax1.imshow(\n                    self.visual_data * self.visual_mask,\n                    norm=LogNorm(),\n                    cmap=color_map,\n                    origin=\"lower\",\n                )\n            else:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                if self.plots_info[\"value_min\"] &lt;= 0:\n                    self.plots_info[\"value_min\"] = 1\n                pos = ax1.imshow(\n                    self.visual_data * self.visual_mask,\n                    norm=LogNorm(\n                        self.plots_info[\"value_min\"], self.plots_info[\"value_max\"]\n                    ),\n                    cmap=color_map,\n                    origin=\"lower\",\n                )\n\n            ax1.scatter(\n                self.initial_guess[0],\n                self.initial_guess[1],\n                color=\"b\",\n                marker=\"o\",\n                edgecolor=\"black\",\n                linewidth=0.5,\n                s=self.plots_info[\"marker_size\"],\n                label=f\"Initial guess:({round(self.initial_guess[0],1)},{round(self.initial_guess[1], 1)})\",\n            )\n\n            if not \"marker_size\" in self.plots_info:\n                self.plots_info[\"marker_size\"] = 20\n            ax1.scatter(\n                int(center[0]),\n                int(center[1]),\n                color=\"r\",\n                marker=\"^\",\n                edgecolor=\"black\",\n                linewidth=0.5,\n                s=self.plots_info[\"marker_size\"],\n                label=f\"Refined detector center:({round(center[0],1)}, {round(center[1],1)})\",\n            )\n\n            cbar = fig.colorbar(pos, ax=ax1, shrink=0.6)\n            cbar.ax.tick_params(labelsize=20)\n            ax1.legend(fontsize=14, loc=1, markerscale=1)\n            plt.tick_params(axis=\"both\", which=\"major\", labelsize=16)\n            ax1.set_xlabel(\"x (pixel)\", fontsize=20)\n            ax1.set_ylabel(\"y (pixel)\", fontsize=20)\n\n            if not self.plots_info[\"axis_lim_auto\"]:\n                ax1.set_xlim(self.plots_info[\"xlim_min\"], self.plots_info[\"xlim_max\"])\n                ax1.set_ylim(self.plots_info[\"ylim_min\"], self.plots_info[\"ylim_max\"])\n\n            path = pathlib.Path(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/centered_friedel/'\n            )\n            path.mkdir(parents=True, exist_ok=True)\n            plt.savefig(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/centered_friedel/{self.plots_info[\"filename\"]}.png'\n            )\n            plt.close(\"all\")\n\n            original_peaks_x = [\n                round(k + self.initial_guess[0]) for k in peak_list_x_in_frame\n            ]\n            original_peaks_y = [\n                round(k + self.initial_guess[1]) for k in peak_list_y_in_frame\n            ]\n\n            inverted_non_shifted_peaks_x = [\n                round(k[0] + self.initial_guess[0]) for k in self.peaks_list_inverted\n            ]\n            inverted_non_shifted_peaks_y = [\n                round(k[1] + self.initial_guess[1]) for k in self.peaks_list_inverted\n            ]\n            inverted_shifted_peaks_x = [\n                round(k[0] + self.initial_guess[0] + shift_x)\n                for k in self.peaks_list_inverted\n            ]\n            inverted_shifted_peaks_y = [\n                round(k[1] + self.initial_guess[1] + shift_y)\n                for k in self.peaks_list_inverted\n            ]\n\n            # Check pairs alignement\n            fig, ax1 = plt.subplots(1, 1, figsize=(10, 10))\n            if self.plots_info[\"value_auto\"]:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                pos = ax1.imshow(\n                    self.visual_data * self.visual_mask,\n                    norm=LogNorm(),\n                    cmap=color_map,\n                    origin=\"lower\",\n                )\n            else:\n                color_map = copy.copy(\n                    matplotlib.colormaps[self.plots_info[\"color_map\"]]\n                )\n                color_map.set_bad(color_map(0))\n                pos = ax1.imshow(\n                    self.visual_data * self.visual_mask,\n                    norm=LogNorm(\n                        self.plots_info[\"value_min\"], self.plots_info[\"value_max\"]\n                    ),\n                    cmap=color_map,\n                    origin=\"lower\",\n                )\n\n            ax1.scatter(\n                original_peaks_x,\n                original_peaks_y,\n                facecolor=\"none\",\n                s=0.8 * self.plots_info[\"marker_size\"],\n                marker=\"o\",\n                edgecolor=\"red\",\n                linewidth=1.8,\n                label=\"original peaks\",\n            )\n\n            ax1.scatter(\n                inverted_non_shifted_peaks_x,\n                inverted_non_shifted_peaks_y,\n                s=1.2 * self.plots_info[\"marker_size\"],\n                facecolor=\"none\",\n                marker=\"s\",\n                edgecolor=\"blue\",\n                linewidth=1.8,\n                label=\"inverted peaks\",\n                alpha=1,\n            )\n            ax1.scatter(\n                inverted_shifted_peaks_x,\n                inverted_shifted_peaks_y,\n                facecolor=\"none\",\n                s=1.2 * self.plots_info[\"marker_size\"],\n                marker=\"D\",\n                linewidth=1.8,\n                alpha=1,\n                edgecolor=\"green\",\n                label=\"inverted peaks shifted\",\n            )\n\n            if not self.plots_info[\"axis_lim_auto\"]:\n                ax1.set_xlim(self.plots_info[\"xlim_min\"], self.plots_info[\"xlim_max\"])\n                ax1.set_ylim(self.plots_info[\"ylim_min\"], self.plots_info[\"ylim_max\"])\n\n            cbar = fig.colorbar(pos, ax=ax1, shrink=0.6)\n            cbar.ax.tick_params(labelsize=20)\n            ax1.legend(fontsize=14, loc=1, markerscale=1)\n            plt.tick_params(axis=\"both\", which=\"major\", labelsize=16)\n            ax1.set_xlabel(\"x (pixel)\", fontsize=20)\n            ax1.set_ylabel(\"y (pixel)\", fontsize=20)\n            path = pathlib.Path(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/peaks/'\n            )\n            path.mkdir(parents=True, exist_ok=True)\n            plt.savefig(\n                f'{self.plots_info[\"root_path\"]}/center_refinement/plots/{self.plots_info[\"folder_name\"]}/peaks/{self.plots_info[\"filename\"]}.png'\n            )\n            plt.close()\n        return center\n</code></pre>"},{"location":"reference/methods/#bblib.methods.CenterOfMass.__init__","title":"<code>__init__(config, PF8Config, plots_info=None)</code>","text":"<p>This method initializes the CenterOfMass centering method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A configuration dictionary in a format expected by beambusters.</p> required <code>PF8Config</code> <code>PF8Info</code> <p>Peakfinder8 parameters.</p> required <code>plots_info</code> <code>dict</code> <p>Configuration parameters to generate plots.</p> <code>None</code> Source code in <code>bblib/methods.py</code> <pre><code>def __init__(self, config: dict, PF8Config: PF8Info, plots_info: dict = None):\n    \"\"\"\n    This method initializes the CenterOfMass centering method.\n\n    Args:\n        config (dict): A configuration dictionary in a format expected by beambusters.\n        PF8Config (PF8Info): Peakfinder8 parameters.\n        plots_info (dict): Configuration parameters to generate plots.\n    \"\"\"\n\n    self.config = config\n    self.PF8Config = PF8Config\n    self.plots_info = plots_info\n\n    if config[\"plots_flag\"] and not plots_info:\n        raise ValueError(\n            \"From config you want to save plots, please indicate the information to save the plots.\"\n        )\n\n    # Creates an empty plots_info dictionary.\n    if not config[\"plots_flag\"] and not plots_info:\n        plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n</code></pre>"},{"location":"reference/methods/#bblib.methods.CircleDetection.__init__","title":"<code>__init__(config, PF8Config, plots_info=None)</code>","text":"<p>This method initializes the CircleDetection centering method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A configuration dictionary in a format expected by beambusters.</p> required <code>PF8Config</code> <code>PF8Info</code> <p>Peakfinder8 parameters.</p> required <code>plots_info</code> <code>dict</code> <p>Configuration parameters to generate plots.</p> <code>None</code> Source code in <code>bblib/methods.py</code> <pre><code>def __init__(self, config: dict, PF8Config: PF8Info, plots_info: dict = None):\n    \"\"\"\n    This method initializes the CircleDetection centering method.\n\n    Args:\n        config (dict): A configuration dictionary in a format expected by beambusters.\n        PF8Config (PF8Info): Peakfinder8 parameters.\n        plots_info (dict): Configuration parameters to generate plots.\n    \"\"\"\n    self.config = config\n    self.PF8Config = PF8Config\n    self.plots_info = plots_info\n    if config[\"plots_flag\"] and not plots_info:\n        raise ValueError(\n            \"From config you want to save plots, please indicate the information to save the plots.\"\n        )\n\n    if not config[\"plots_flag\"] and not plots_info:\n        plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n</code></pre>"},{"location":"reference/methods/#bblib.methods.MinimizePeakFWHM.__init__","title":"<code>__init__(config, PF8Config, plots_info=None)</code>","text":"<p>This method initializes the MinimizePeakFWHM centering method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A configuration dictionary in a format expected by beambusters.</p> required <code>PF8Config</code> <code>PF8Info</code> <p>Peakfinder8 parameters.</p> required <code>plots_info</code> <code>dict</code> <p>Configuration parameters to generate plots.</p> <code>None</code> Source code in <code>bblib/methods.py</code> <pre><code>def __init__(self, config: dict, PF8Config: PF8Info, plots_info: dict = None):\n    \"\"\"\n    This method initializes the MinimizePeakFWHM centering method.\n\n    Args:\n        config (dict): A configuration dictionary in a format expected by beambusters.\n        PF8Config (PF8Info): Peakfinder8 parameters.\n        plots_info (dict): Configuration parameters to generate plots.\n    \"\"\"\n    self.config = config\n    self.PF8Config = PF8Config\n    self.plots_info = plots_info\n    self.plot_fwhm_flag = False\n    if config[\"plots_flag\"] and not plots_info:\n        raise ValueError(\n            \"From config you want to save plots, please indicate the information to save the plots.\"\n        )\n\n    if not config[\"plots_flag\"] and not plots_info:\n        plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n</code></pre>"},{"location":"reference/methods/#bblib.methods.FriedelPairs.__init__","title":"<code>__init__(config, PF8Config, plots_info=None)</code>","text":"<p>This method initializes the FriedelPairs centering method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A configuration dictionary in a format expected by beambusters.</p> required <code>PF8Config</code> <code>PF8Info</code> <p>Peakfinder8 parameters.</p> required <code>plots_info</code> <code>dict</code> <p>Configuration parameters to generate plots.</p> <code>None</code> Source code in <code>bblib/methods.py</code> <pre><code>def __init__(self, config: dict, PF8Config: PF8Info, plots_info: dict = None):\n    \"\"\"\n    This method initializes the FriedelPairs centering method.\n\n    Args:\n        config (dict): A configuration dictionary in a format expected by beambusters.\n        PF8Config (PF8Info): Peakfinder8 parameters.\n        plots_info (dict): Configuration parameters to generate plots.\n    \"\"\"\n    self.config = config\n    self.PF8Config = PF8Config\n    self.plots_info = plots_info\n    if config[\"plots_flag\"] and not plots_info:\n        raise ValueError(\n            \"From config you want to save plots, please indicate the information to save the plots.\"\n        )\n\n    if not config[\"plots_flag\"] and not plots_info:\n        plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n</code></pre>"},{"location":"reference/models/","title":"Models","text":"<p>This module import peakfinder8 from the OnDA monitor and add extra features.</p>"},{"location":"reference/models/#bblib.models.PF8","title":"<code>PF8</code>","text":"<p>This class defines an object that determine the Bragg peaks using the peakfinder8 algorithm from OnDA monitor.</p> Source code in <code>bblib/models.py</code> <pre><code>class PF8:\n    \"\"\"\n    This class defines an object that determine the Bragg peaks using the peakfinder8 algorithm from OnDA monitor.\n    \"\"\"\n\n    def __init__(self, info):\n        \"\"\"\n        This method initilizes the PF8 class.\n\n        Args:\n            info (PF8Info): Peakfinder8 parameters.\n        \"\"\"\n        assert isinstance(\n            info, PF8Info\n        ), f\"Info object expected type PF8Info, found {type(info)}.\"\n        self.pf8_param = info\n\n    def get_peaks_pf8(self, data: np.ndarray):\n        \"\"\"\n        This method determines the Bragg peaks positions using the peakfinder8 algorithm from OnDA monitor.\n\n        Args:\n            data (np.ndarray): Data in which the peakfinder8 will be performed.\n\n        Returns:\n            peak_list (dict): Bragg peaks position in the fast-scan/slow-scan axis, their integrated intensity and maximum intensity\n        \"\"\"\n        self._radius_pixel_map = self.pf8_param.pixel_maps[\"radius\"]\n        self._data_shape: Tuple[int, ...] = self._radius_pixel_map.shape\n        self._flattened_visualization_pixel_map_x = self.pf8_param.pixel_maps[\n            \"x\"\n        ].flatten()\n        self._flattened_visualization_pixel_map_y = self.pf8_param.pixel_maps[\n            \"y\"\n        ].flatten()\n        peak_detection = Peakfinder8PeakDetection(\n            radius_pixel_map=(self.pf8_param.pixel_maps[\"radius\"]).astype(np.float32),\n            layout_info=self.pf8_param.pf8_detector_info,\n            crystallography_parameters=self.pf8_param,\n        )\n        peak_list = peak_detection.find_peaks(data=data)\n        return peak_list\n\n    def peak_list_in_slab(self, peak_list):\n        \"\"\"\n        This method transforms the Bragg peaks positions in the fast-scan/slow-scan axis to Cartesian (x/y) coordinates using the visualization pixel map.\n        Args:\n            peak_list (dict): Bragg peaks list determined by peakfinder8.\n\n        Returns:\n            peaks_coordinates (tuple): Bragg peaks x and y coordinates in the visualization frame.\n\n        \"\"\"\n        peak_list_x_in_frame: List[float] = []\n        peak_list_y_in_frame: List[float] = []\n        peak_fs: float\n        peak_ss: float\n        peak_value: float\n        for peak_fs, peak_ss, peak_value, peak_max_pixel_intensity in zip(\n            peak_list[\"fs\"],\n            peak_list[\"ss\"],\n            peak_list[\"intensity\"],\n            peak_list[\"max_pixel_intensity\"],\n        ):\n            peak_index_in_slab: int = int(round(peak_ss)) * self._data_shape[1] + int(\n                round(peak_fs)\n            )\n            y_in_frame: float = self._flattened_visualization_pixel_map_y[\n                peak_index_in_slab\n            ]\n            x_in_frame: float = self._flattened_visualization_pixel_map_x[\n                peak_index_in_slab\n            ]\n            peak_list_x_in_frame.append(x_in_frame)\n            peak_list_y_in_frame.append(y_in_frame)\n\n        return peak_list_x_in_frame, peak_list_y_in_frame\n</code></pre>"},{"location":"reference/models/#bblib.models.PF8.__init__","title":"<code>__init__(info)</code>","text":"<p>This method initilizes the PF8 class.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>PF8Info</code> <p>Peakfinder8 parameters.</p> required Source code in <code>bblib/models.py</code> <pre><code>def __init__(self, info):\n    \"\"\"\n    This method initilizes the PF8 class.\n\n    Args:\n        info (PF8Info): Peakfinder8 parameters.\n    \"\"\"\n    assert isinstance(\n        info, PF8Info\n    ), f\"Info object expected type PF8Info, found {type(info)}.\"\n    self.pf8_param = info\n</code></pre>"},{"location":"reference/models/#bblib.models.PF8.get_peaks_pf8","title":"<code>get_peaks_pf8(data)</code>","text":"<p>This method determines the Bragg peaks positions using the peakfinder8 algorithm from OnDA monitor.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Data in which the peakfinder8 will be performed.</p> required <p>Returns:</p> Name Type Description <code>peak_list</code> <code>dict</code> <p>Bragg peaks position in the fast-scan/slow-scan axis, their integrated intensity and maximum intensity</p> Source code in <code>bblib/models.py</code> <pre><code>def get_peaks_pf8(self, data: np.ndarray):\n    \"\"\"\n    This method determines the Bragg peaks positions using the peakfinder8 algorithm from OnDA monitor.\n\n    Args:\n        data (np.ndarray): Data in which the peakfinder8 will be performed.\n\n    Returns:\n        peak_list (dict): Bragg peaks position in the fast-scan/slow-scan axis, their integrated intensity and maximum intensity\n    \"\"\"\n    self._radius_pixel_map = self.pf8_param.pixel_maps[\"radius\"]\n    self._data_shape: Tuple[int, ...] = self._radius_pixel_map.shape\n    self._flattened_visualization_pixel_map_x = self.pf8_param.pixel_maps[\n        \"x\"\n    ].flatten()\n    self._flattened_visualization_pixel_map_y = self.pf8_param.pixel_maps[\n        \"y\"\n    ].flatten()\n    peak_detection = Peakfinder8PeakDetection(\n        radius_pixel_map=(self.pf8_param.pixel_maps[\"radius\"]).astype(np.float32),\n        layout_info=self.pf8_param.pf8_detector_info,\n        crystallography_parameters=self.pf8_param,\n    )\n    peak_list = peak_detection.find_peaks(data=data)\n    return peak_list\n</code></pre>"},{"location":"reference/models/#bblib.models.PF8.peak_list_in_slab","title":"<code>peak_list_in_slab(peak_list)</code>","text":"<p>This method transforms the Bragg peaks positions in the fast-scan/slow-scan axis to Cartesian (x/y) coordinates using the visualization pixel map. Args:     peak_list (dict): Bragg peaks list determined by peakfinder8.</p> <p>Returns:</p> Name Type Description <code>peaks_coordinates</code> <code>tuple</code> <p>Bragg peaks x and y coordinates in the visualization frame.</p> Source code in <code>bblib/models.py</code> <pre><code>def peak_list_in_slab(self, peak_list):\n    \"\"\"\n    This method transforms the Bragg peaks positions in the fast-scan/slow-scan axis to Cartesian (x/y) coordinates using the visualization pixel map.\n    Args:\n        peak_list (dict): Bragg peaks list determined by peakfinder8.\n\n    Returns:\n        peaks_coordinates (tuple): Bragg peaks x and y coordinates in the visualization frame.\n\n    \"\"\"\n    peak_list_x_in_frame: List[float] = []\n    peak_list_y_in_frame: List[float] = []\n    peak_fs: float\n    peak_ss: float\n    peak_value: float\n    for peak_fs, peak_ss, peak_value, peak_max_pixel_intensity in zip(\n        peak_list[\"fs\"],\n        peak_list[\"ss\"],\n        peak_list[\"intensity\"],\n        peak_list[\"max_pixel_intensity\"],\n    ):\n        peak_index_in_slab: int = int(round(peak_ss)) * self._data_shape[1] + int(\n            round(peak_fs)\n        )\n        y_in_frame: float = self._flattened_visualization_pixel_map_y[\n            peak_index_in_slab\n        ]\n        x_in_frame: float = self._flattened_visualization_pixel_map_x[\n            peak_index_in_slab\n        ]\n        peak_list_x_in_frame.append(x_in_frame)\n        peak_list_y_in_frame.append(y_in_frame)\n\n    return peak_list_x_in_frame, peak_list_y_in_frame\n</code></pre>"},{"location":"reference/models/#bblib.models.PF8Info","title":"<code>PF8Info</code>  <code>dataclass</code>","text":"<p>This class defines the configuration parameters for peakfinder8.</p> <p>Attributes:</p> Name Type Description <code>max_num_peaks</code> <code>int32</code> <p>Maximum number of peaks.</p> <code>adc_threshold</code> <code>int32</code> <p>Minimum threshold in arbitrary detector counts (ADC) units.</p> <code>minimum_snr</code> <code>float32</code> <p>Minimum signal-to-noise ration.</p> <code>min_pixel_count</code> <code>int16</code> <p>Minimum number of pixels to consider a Bragg peak.</p> <code>max_pixel_count</code> <code>int16</code> <p>Maximum number of pixels to consider a Bragg peak.</p> <code>local_bg_radius</code> <code>int16</code> <p>Local bakground radius in pixels.</p> <code>min_res</code> <code>int16</code> <p>Minimum resolution ring in pixels.</p> <code>max_res</code> <code>int16</code> <p>Maximum resolution ring in pixels.</p> <code>pf8_detector_info</code> <code>TypeDetectorLayoutInformation</code> <p>Detector layout information.</p> <code>bad_pixel_map_filename</code> <code>str</code> <p>Path to the bad pixels map (mask).</p> <code>bad_pixel_map_hdf5_path</code> <code>str</code> <p>Key to acess the bad pixel map (mask).</p> <code>pixel_maps</code> <code>TypePixelMaps</code> <p>Map of the pixels positions in the laboratory coordinates.</p> <code>pixel_resolution</code> <code>float</code> <p>Reciprocal of the pixel size (1/m).</p> <code>geometry_txt</code> <code>list</code> <p>Content of the geometry file (.geom), in CrystFEL format.</p> Source code in <code>bblib/models.py</code> <pre><code>@dataclass\nclass PF8Info:\n    \"\"\"\n    This class defines the configuration parameters for peakfinder8.\n\n    Attributes:\n        max_num_peaks (np.int32): Maximum number of peaks.\n        adc_threshold (np.int32): Minimum threshold in arbitrary detector counts (ADC) units.\n        minimum_snr (np.float32): Minimum signal-to-noise ration.\n        min_pixel_count (np.int16): Minimum number of pixels to consider a Bragg peak.\n        max_pixel_count (np.int16): Maximum number of pixels to consider a Bragg peak.\n        local_bg_radius (np.int16): Local bakground radius in pixels.\n        min_res (np.int16): Minimum resolution ring in pixels.\n        max_res (np.int16): Maximum resolution ring in pixels.\n        pf8_detector_info (TypeDetectorLayoutInformation): Detector layout information.\n        bad_pixel_map_filename (str): Path to the bad pixels map (mask).\n        bad_pixel_map_hdf5_path (str): Key to acess the bad pixel map (mask).\n        pixel_maps (TypePixelMaps): Map of the pixels positions in the laboratory coordinates.\n        pixel_resolution (float): Reciprocal of the pixel size (1/m).\n        geometry_txt (list): Content of the geometry file (.geom), in CrystFEL format.\n    \"\"\"\n\n    max_num_peaks: np.int32 = 200\n    adc_threshold: np.int32 = 0\n    minimum_snr: np.float32 = 5\n    min_pixel_count: np.int16 = 2\n    max_pixel_count: np.int16 = 2000\n    local_bg_radius: np.int16 = 3\n    min_res: np.int16 = 0\n    max_res: np.int16 = 1200\n    pf8_detector_info: TypeDetectorLayoutInformation = None\n    bad_pixel_map_filename: str = None\n    bad_pixel_map_hdf5_path: str = None\n    pixel_maps: TypePixelMaps = None\n    pixel_resolution: float = None\n    _shifted_pixel_maps: bool = False\n    geometry_txt: list = None\n\n    def update_pixel_maps(self, detector_shift_x: float, detector_shift_y: float):\n        \"\"\"\n        This module checks whether the pixel maps have been shifted. If not, it shifts the entire detector along the x and y axes by the specified values.\n\n        Args:\n            detector_shift_x (float): Number of pixels to shift the entire detector in the x-axis, according to the CXI coordinate system.\n            detector_shift_y (float): Number of pixels to shift the entire detector in the y-axis, according to the CXI coordinate system.\n        \"\"\"\n\n        if not self._shifted_pixel_maps:\n            self._detector_shift_x = detector_shift_x\n            self._detector_shift_y = detector_shift_y\n            self._shifted_pixel_maps = True\n            self.pixel_maps[\"x\"] = (\n                self.pixel_maps[\"x\"].flatten() - detector_shift_x\n            ).reshape(self._data_shape)\n            self.pixel_maps[\"y\"] = (\n                self.pixel_maps[\"y\"].flatten() - detector_shift_y\n            ).reshape(self._data_shape)\n            self.pixel_maps[\"radius\"] = np.sqrt(\n                np.square(self.pixel_maps[\"x\"]) + np.square(self.pixel_maps[\"y\"])\n            ).reshape(self._data_shape)\n            self.pixel_maps[\"phi\"] = np.arctan2(\n                self.pixel_maps[\"y\"], self.pixel_maps[\"x\"]\n            )\n        else:\n            raise ValueError(\n                f\"Pixel maps have been moved once before, to avoid errors reset the geometry before moving it again.\"\n            )\n\n    def set_geometry_from_file(self, geometry_filename: str = None):\n        \"\"\"\n        This module sets the class attributes in accordance with the CrystFEL geometry file (.geom).\n\n        Args:\n            geometry_filename (str): Path to the CrystFEL geometry file (.geom).\n        \"\"\"\n        if geometry_filename:\n            self.geometry_txt = open(geometry_filename, \"r\").readlines()\n        else:\n            if not self.geometry_txt:\n                raise ValueError(\n                    \"Please, specify the detector geometry in CrystFEL format.\"\n                )\n\n        # Passing bad pixel maps to PF8.\n        # Warning! It will look for campus in the geom file either 'mask0_file' or 'mask_file'.\n        # It doesn't look for multiple masks.\n        # It assumes bad pixels as zeros and good pixels as ones.\n        try:\n            self.bad_pixel_map_filename = [\n                x.split(\" = \")[-1][:-1]\n                for x in self.geometry_txt\n                if x.split(\" = \")[0] == \"mask0_file\"\n            ][0]\n        except IndexError:\n            self.bad_pixel_map_filename = [\n                x.split(\" = \")[-1][:-1]\n                for x in self.geometry_txt\n                if x.split(\" = \")[0] == \"mask_file\"\n            ][0]\n\n        try:\n            self.bad_pixel_map_hdf5_path = [\n                x.split(\" = \")[-1][:-1]\n                for x in self.geometry_txt\n                if x.split(\" = \")[0] == \"mask0_data\"\n            ][0]\n        except IndexError:\n            self.bad_pixel_map_hdf5_path = [\n                x.split(\" = \")[-1][:-1]\n                for x in self.geometry_txt\n                if x.split(\" = \")[0] == \"mask\"\n            ][0]\n\n        geom = GeometryInformation(\n            geometry_description=self.geometry_txt, geometry_format=\"crystfel\"\n        )\n        self.pixel_resolution = 1 / geom.get_pixel_size()\n        self.pixel_maps = geom.get_pixel_maps()\n        self._data_shape = self.pixel_maps[\"x\"].shape\n        self._flattened_data_shape = self.pixel_maps[\"x\"].flatten().shape[0]\n        self.pf8_detector_info = geom.get_layout_info()\n        self._shifted_pixel_maps = False\n        self.detector_center_from_geom = self.get_detector_center()\n\n        if (\n            self.pf8_detector_info[\"nasics_x\"] * self.pf8_detector_info[\"nasics_y\"]\n        ) == 1:\n            ## Get single panel transformation matrix from the geometry file\n            ### Warning! Check carefully if the visualized data after reorientation of the panel makes sense, e.g. if it is equal to the real experimental data geometry.\n            detector, _, _ = _read_crystfel_geometry_from_text(\n                text_lines=self.geometry_txt\n            )\n\n            detector_panels = dict(detector[\"panels\"])\n            panel_name = list(detector_panels.keys())[0]\n            frame_dim_structure = [\n                x\n                for x in detector_panels[panel_name][\"dim_structure\"]\n                if x == \"ss\" or x == \"fs\"\n            ]\n            if frame_dim_structure[0] == \"ss\":\n                self.ss_in_rows = True\n            else:\n                self.ss_in_rows = False\n\n            fs_string = [\n                x.split(\" = \")[-1][:-1]\n                for x in self.geometry_txt\n                if (x.split(\" = \")[0]).split(\"/\")[-1] == \"fs\"\n            ][0]\n\n            ss_string = [\n                x.split(\" = \")[-1][:-1]\n                for x in self.geometry_txt\n                if (x.split(\" = \")[0]).split(\"/\")[-1] == \"ss\"\n            ][0]\n            pattern = r\"([-+]?\\d*\\.?\\d+)(?=[xyz])\"\n\n            try:\n                fsx, fsy, fsz = re.findall(pattern, fs_string)\n            except ValueError:\n                fsx, fsy = re.findall(pattern, fs_string)\n\n            try:\n                ssx, ssy, ssz = re.findall(pattern, ss_string)\n            except ValueError:\n                ssx, ssy = re.findall(pattern, ss_string)\n\n            ## The transformation matrix here is only for visualization purposes. Small stretching factors won't have an impact on the visualization of the images (slabby data).\n            self.transformation_matrix_for_visualization = [\n                [\n                    round(float(fsx)),\n                    round(float(fsy)),\n                ],\n                [\n                    round(float(ssx)),\n                    round(float(ssy)),\n                ],\n            ]\n\n    def get(self, parameter: str):\n        \"\"\"\n        This module return the peakfinder8 parameters.\n\n        Args:\n            parameter (str): Peakfinder8 parameter.\n        \"\"\"\n        if parameter == \"max_num_peaks\":\n            return self.max_num_peaks\n        elif parameter == \"adc_threshold\":\n            return self.adc_threshold\n        elif parameter == \"minimum_snr\":\n            return self.minimum_snr\n        elif parameter == \"min_pixel_count\":\n            return self.min_pixel_count\n        elif parameter == \"max_pixel_count\":\n            return self.max_pixel_count\n        elif parameter == \"local_bg_radius\":\n            return self.local_bg_radius\n        elif parameter == \"min_res\":\n            return self.min_res\n        elif parameter == \"max_res\":\n            return self.max_res\n        elif parameter == \"bad_pixel_map_filename\":\n            return self.bad_pixel_map_filename\n        elif parameter == \"bad_pixel_map_hdf5_path\":\n            return self.bad_pixel_map_hdf5_path\n\n    def get_detector_center(self) -&gt; list:\n        \"\"\"\n        This module return the detector center in x/y.\n\n        Returns:\n            center (list): The detector center in x/y.\n        \"\"\"\n        if not self._shifted_pixel_maps:\n\n            if (\n                self.pf8_detector_info[\"nasics_x\"] * self.pf8_detector_info[\"nasics_y\"]\n                &gt; 1\n            ):\n                # Multiple panels\n                # Get minimum array shape\n                y_minimum = (\n                    2\n                    *   max(\n                            abs(self.pixel_maps[\"y\"].max()),\n                            abs(self.pixel_maps[\"y\"].min()),\n                        )\n\n                    + 2\n                )\n                x_minimum = (\n                    2\n                    *   max(\n                            abs(self.pixel_maps[\"x\"].max()),\n                            abs(self.pixel_maps[\"x\"].min()),\n                        )\n\n                    + 2\n                )\n                visual_img_shape = (y_minimum, x_minimum)\n                # Detector center in the middle of the minimum array\n                _img_center_x = visual_img_shape[1] / 2 - 1\n                _img_center_y = visual_img_shape[0] / 2 - 1\n            else:\n                # Single panel\n                _img_center_x = abs(np.min(self.pixel_maps[\"x\"]))\n                _img_center_y = abs(np.min(self.pixel_maps[\"y\"]))\n        else:\n            print(\n                \"Warning! The detector center was moved by a previous operation, the detector center is not the same as in the geometry file.\"\n            )\n            _img_center_x = self.detector_center_from_geom[0] + self._detector_shift_x\n            _img_center_y = self.detector_center_from_geom[1] + self._detector_shift_y\n        return [_img_center_x, _img_center_y]\n</code></pre>"},{"location":"reference/models/#bblib.models.PF8Info.get","title":"<code>get(parameter)</code>","text":"<p>This module return the peakfinder8 parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>str</code> <p>Peakfinder8 parameter.</p> required Source code in <code>bblib/models.py</code> <pre><code>def get(self, parameter: str):\n    \"\"\"\n    This module return the peakfinder8 parameters.\n\n    Args:\n        parameter (str): Peakfinder8 parameter.\n    \"\"\"\n    if parameter == \"max_num_peaks\":\n        return self.max_num_peaks\n    elif parameter == \"adc_threshold\":\n        return self.adc_threshold\n    elif parameter == \"minimum_snr\":\n        return self.minimum_snr\n    elif parameter == \"min_pixel_count\":\n        return self.min_pixel_count\n    elif parameter == \"max_pixel_count\":\n        return self.max_pixel_count\n    elif parameter == \"local_bg_radius\":\n        return self.local_bg_radius\n    elif parameter == \"min_res\":\n        return self.min_res\n    elif parameter == \"max_res\":\n        return self.max_res\n    elif parameter == \"bad_pixel_map_filename\":\n        return self.bad_pixel_map_filename\n    elif parameter == \"bad_pixel_map_hdf5_path\":\n        return self.bad_pixel_map_hdf5_path\n</code></pre>"},{"location":"reference/models/#bblib.models.PF8Info.get_detector_center","title":"<code>get_detector_center()</code>","text":"<p>This module return the detector center in x/y.</p> <p>Returns:</p> Name Type Description <code>center</code> <code>list</code> <p>The detector center in x/y.</p> Source code in <code>bblib/models.py</code> <pre><code>def get_detector_center(self) -&gt; list:\n    \"\"\"\n    This module return the detector center in x/y.\n\n    Returns:\n        center (list): The detector center in x/y.\n    \"\"\"\n    if not self._shifted_pixel_maps:\n\n        if (\n            self.pf8_detector_info[\"nasics_x\"] * self.pf8_detector_info[\"nasics_y\"]\n            &gt; 1\n        ):\n            # Multiple panels\n            # Get minimum array shape\n            y_minimum = (\n                2\n                *   max(\n                        abs(self.pixel_maps[\"y\"].max()),\n                        abs(self.pixel_maps[\"y\"].min()),\n                    )\n\n                + 2\n            )\n            x_minimum = (\n                2\n                *   max(\n                        abs(self.pixel_maps[\"x\"].max()),\n                        abs(self.pixel_maps[\"x\"].min()),\n                    )\n\n                + 2\n            )\n            visual_img_shape = (y_minimum, x_minimum)\n            # Detector center in the middle of the minimum array\n            _img_center_x = visual_img_shape[1] / 2 - 1\n            _img_center_y = visual_img_shape[0] / 2 - 1\n        else:\n            # Single panel\n            _img_center_x = abs(np.min(self.pixel_maps[\"x\"]))\n            _img_center_y = abs(np.min(self.pixel_maps[\"y\"]))\n    else:\n        print(\n            \"Warning! The detector center was moved by a previous operation, the detector center is not the same as in the geometry file.\"\n        )\n        _img_center_x = self.detector_center_from_geom[0] + self._detector_shift_x\n        _img_center_y = self.detector_center_from_geom[1] + self._detector_shift_y\n    return [_img_center_x, _img_center_y]\n</code></pre>"},{"location":"reference/models/#bblib.models.PF8Info.set_geometry_from_file","title":"<code>set_geometry_from_file(geometry_filename=None)</code>","text":"<p>This module sets the class attributes in accordance with the CrystFEL geometry file (.geom).</p> <p>Parameters:</p> Name Type Description Default <code>geometry_filename</code> <code>str</code> <p>Path to the CrystFEL geometry file (.geom).</p> <code>None</code> Source code in <code>bblib/models.py</code> <pre><code>def set_geometry_from_file(self, geometry_filename: str = None):\n    \"\"\"\n    This module sets the class attributes in accordance with the CrystFEL geometry file (.geom).\n\n    Args:\n        geometry_filename (str): Path to the CrystFEL geometry file (.geom).\n    \"\"\"\n    if geometry_filename:\n        self.geometry_txt = open(geometry_filename, \"r\").readlines()\n    else:\n        if not self.geometry_txt:\n            raise ValueError(\n                \"Please, specify the detector geometry in CrystFEL format.\"\n            )\n\n    # Passing bad pixel maps to PF8.\n    # Warning! It will look for campus in the geom file either 'mask0_file' or 'mask_file'.\n    # It doesn't look for multiple masks.\n    # It assumes bad pixels as zeros and good pixels as ones.\n    try:\n        self.bad_pixel_map_filename = [\n            x.split(\" = \")[-1][:-1]\n            for x in self.geometry_txt\n            if x.split(\" = \")[0] == \"mask0_file\"\n        ][0]\n    except IndexError:\n        self.bad_pixel_map_filename = [\n            x.split(\" = \")[-1][:-1]\n            for x in self.geometry_txt\n            if x.split(\" = \")[0] == \"mask_file\"\n        ][0]\n\n    try:\n        self.bad_pixel_map_hdf5_path = [\n            x.split(\" = \")[-1][:-1]\n            for x in self.geometry_txt\n            if x.split(\" = \")[0] == \"mask0_data\"\n        ][0]\n    except IndexError:\n        self.bad_pixel_map_hdf5_path = [\n            x.split(\" = \")[-1][:-1]\n            for x in self.geometry_txt\n            if x.split(\" = \")[0] == \"mask\"\n        ][0]\n\n    geom = GeometryInformation(\n        geometry_description=self.geometry_txt, geometry_format=\"crystfel\"\n    )\n    self.pixel_resolution = 1 / geom.get_pixel_size()\n    self.pixel_maps = geom.get_pixel_maps()\n    self._data_shape = self.pixel_maps[\"x\"].shape\n    self._flattened_data_shape = self.pixel_maps[\"x\"].flatten().shape[0]\n    self.pf8_detector_info = geom.get_layout_info()\n    self._shifted_pixel_maps = False\n    self.detector_center_from_geom = self.get_detector_center()\n\n    if (\n        self.pf8_detector_info[\"nasics_x\"] * self.pf8_detector_info[\"nasics_y\"]\n    ) == 1:\n        ## Get single panel transformation matrix from the geometry file\n        ### Warning! Check carefully if the visualized data after reorientation of the panel makes sense, e.g. if it is equal to the real experimental data geometry.\n        detector, _, _ = _read_crystfel_geometry_from_text(\n            text_lines=self.geometry_txt\n        )\n\n        detector_panels = dict(detector[\"panels\"])\n        panel_name = list(detector_panels.keys())[0]\n        frame_dim_structure = [\n            x\n            for x in detector_panels[panel_name][\"dim_structure\"]\n            if x == \"ss\" or x == \"fs\"\n        ]\n        if frame_dim_structure[0] == \"ss\":\n            self.ss_in_rows = True\n        else:\n            self.ss_in_rows = False\n\n        fs_string = [\n            x.split(\" = \")[-1][:-1]\n            for x in self.geometry_txt\n            if (x.split(\" = \")[0]).split(\"/\")[-1] == \"fs\"\n        ][0]\n\n        ss_string = [\n            x.split(\" = \")[-1][:-1]\n            for x in self.geometry_txt\n            if (x.split(\" = \")[0]).split(\"/\")[-1] == \"ss\"\n        ][0]\n        pattern = r\"([-+]?\\d*\\.?\\d+)(?=[xyz])\"\n\n        try:\n            fsx, fsy, fsz = re.findall(pattern, fs_string)\n        except ValueError:\n            fsx, fsy = re.findall(pattern, fs_string)\n\n        try:\n            ssx, ssy, ssz = re.findall(pattern, ss_string)\n        except ValueError:\n            ssx, ssy = re.findall(pattern, ss_string)\n\n        ## The transformation matrix here is only for visualization purposes. Small stretching factors won't have an impact on the visualization of the images (slabby data).\n        self.transformation_matrix_for_visualization = [\n            [\n                round(float(fsx)),\n                round(float(fsy)),\n            ],\n            [\n                round(float(ssx)),\n                round(float(ssy)),\n            ],\n        ]\n</code></pre>"},{"location":"reference/models/#bblib.models.PF8Info.update_pixel_maps","title":"<code>update_pixel_maps(detector_shift_x, detector_shift_y)</code>","text":"<p>This module checks whether the pixel maps have been shifted. If not, it shifts the entire detector along the x and y axes by the specified values.</p> <p>Parameters:</p> Name Type Description Default <code>detector_shift_x</code> <code>float</code> <p>Number of pixels to shift the entire detector in the x-axis, according to the CXI coordinate system.</p> required <code>detector_shift_y</code> <code>float</code> <p>Number of pixels to shift the entire detector in the y-axis, according to the CXI coordinate system.</p> required Source code in <code>bblib/models.py</code> <pre><code>def update_pixel_maps(self, detector_shift_x: float, detector_shift_y: float):\n    \"\"\"\n    This module checks whether the pixel maps have been shifted. If not, it shifts the entire detector along the x and y axes by the specified values.\n\n    Args:\n        detector_shift_x (float): Number of pixels to shift the entire detector in the x-axis, according to the CXI coordinate system.\n        detector_shift_y (float): Number of pixels to shift the entire detector in the y-axis, according to the CXI coordinate system.\n    \"\"\"\n\n    if not self._shifted_pixel_maps:\n        self._detector_shift_x = detector_shift_x\n        self._detector_shift_y = detector_shift_y\n        self._shifted_pixel_maps = True\n        self.pixel_maps[\"x\"] = (\n            self.pixel_maps[\"x\"].flatten() - detector_shift_x\n        ).reshape(self._data_shape)\n        self.pixel_maps[\"y\"] = (\n            self.pixel_maps[\"y\"].flatten() - detector_shift_y\n        ).reshape(self._data_shape)\n        self.pixel_maps[\"radius\"] = np.sqrt(\n            np.square(self.pixel_maps[\"x\"]) + np.square(self.pixel_maps[\"y\"])\n        ).reshape(self._data_shape)\n        self.pixel_maps[\"phi\"] = np.arctan2(\n            self.pixel_maps[\"y\"], self.pixel_maps[\"x\"]\n        )\n    else:\n        raise ValueError(\n            f\"Pixel maps have been moved once before, to avoid errors reset the geometry before moving it again.\"\n        )\n</code></pre>"},{"location":"reference/usage/","title":"Usage","text":""},{"location":"reference/usage/#configuration-dictionaries","title":"Configuration dictionaries","text":"<p>To utilize the methods <code>CenterOfMass</code>,  <code>FriedelPairs</code>, <code>MinimizePeakFWHM</code>  and <code>CircleDetection</code> it is required to have two configuration dictionaries, one for PeakFinder8 and another one for this library itself. The following snippet shows the general structure for both (parameters not used in your case can be omitted):</p> <pre><code>config = {\n    \"plots_flag\": ...,\n    \"search_radius\": ...,\n    \"pf8\": {\n        \"max_num_peaks\": ...,\n        \"adc_threshold\": ...,\n        \"minimum_snr\": ...,\n        \"min_pixel_count\": ...,\n        \"max_pixel_count\": ...,\n        \"local_bg_radius\": ...,\n        \"min_res\": ...,\n        \"max_res\": ...\n        },\n    \"peak_region\":{\n        \"min\": ...,\n        \"max\": ...\n        },\n    \"grid_search_radius\": ...,\n    \"canny\":{\n        \"sigma\": ...,\n        \"low_threshold\": ...,\n        \"high_threshold\": ...\n        },\n    \"hough_rank\": ...,\n    \"bragg_peaks_for_center_of_mass_calculation\": ...,\n    \"pixels_for_mask_of_bragg_peaks\": ...,\n    \"polarization\": {\n        \"apply_polarization_correction\": ...,\n        \"axis\": ...,\n        \"value\": ...\n        }\n}\n\nPF8Info = {\n    \"max_num_peaks\":\n    \"adc_threshold\":\n    \"minimum_snr\": ...,\n    \"min_pixel_count\": ...,\n    \"max_pixel_count\": ...,\n    \"local_bg_radius\": ...,\n    \"min_res\": ...,\n    \"max_res\": ...,\n    \"pf8_detector_info\": ...,\n    \"bad_pixel_map_filename\": ...,\n    \"bad_pixel_map_hdf5_path\": ...,\n    \"pixel_maps\": ...,\n    \"pixel_resolution\": ...,\n    \"_shifted_pixel_maps\":...\n}\n</code></pre> <p>The <code>pf8_detector_info</code> parameter is a dictionary containing the detector layout information: <pre><code>pf8_detector_info =  {\n    \"asic_nx\": ...,\n    \"asic_ny\": ...,\n    \"nasics_x\": ...,\n    \"nasics_y\": ...\n}\n</code></pre></p> <p>The <code>pixel_maps</code> parameter is a dictionary containing the pixel maps numpy array: <pre><code>pixel_maps =  {\n    \"x\": ...,\n    \"y\": ...,\n    \"z\": ...,\n    \"radius\": ...,\n    \"phi\": ...\n}\n</code></pre></p> <p>The methods <code>FriedelPairs</code>, <code>MinimizePeakFWHM</code> and  <code>CircleDetection</code> need a <code>plots_info</code> parameter if you want to save plots: <pre><code>plots_info =  {\n    \"filename\": ...,\n    \"folder_name\": ...,\n    \"root_path\": ...,\n    \"value_auto\": ...,\n    \"value_max\": ...,\n    \"value_min\": ...,\n    \"axis_lim_auto\": ...,\n    \"xlim_min\": ...,\n    \"xlim_max\": ...,\n    \"ylim_min\": ...,\n    \"ylim_max\": ...,\n    \"color_map\": ...,\n    \"marker_size\": ...\n}\n</code></pre></p>"},{"location":"reference/usage/#calling-the-methods","title":"Calling the methods","text":"<p>To calculate the refined detector center of raw data frame as a numpy array using the following methods:</p> <pre><code>from bblib.methods import CenterOfMass\ncenter_of_mass_method = CenterOfMass(config=config, PF8Config=PF8Config, plots_info=plots_info)\ncenter_coordinates_from_center_of_mass = center_of_mass_method(\n                        data = ...\n                    )\n\nfrom bblib.methods import CircleDetection\ncircle_detection_method = CircleDetection(config=config, PF8Config=PF8Config, plots_info=plots_info)\ncenter_coordinates_from_circle_detection = circle_detection_method(\n                        data = ...\n                    )\n</code></pre> <p>The <code>FriedelPairs</code> and <code>MinimizePeakFWHMmethod</code> need an initial guess for the refined detector center coordinates <code>initial_guess = [x_0, y_0]</code></p> <pre><code>from bblib.methods import MinimizePeakFWHM\nminimize_peak_fwhm_method = MinimizePeakFWHM(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\ncenter_coordinates_from_minimize_peak_fwhm = minimize_peak_fwhm_method(\n                        data = ..., initial_guess = ...\n                    )\n\n\nfrom bblib.methods import FriedelPairs\nfriedel_pairs_method = FriedelPairs(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\ncenter_coordinates_from_friedel_pairs = friedel_pairs_method(\n                        data = ..., initial_guess= ...\n                    )\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":"<p>This module defines auxiliary funtions to process the data.</p>"},{"location":"reference/utils/#bblib.utils.azimuthal_average_fast","title":"<code>azimuthal_average_fast(data, center=None, mask=None)</code>","text":"<p>Returns intensity over radius, where intensity is the mean per integer radius. Improve performance.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.</p> required <code>center</code> <code>tuple</code> <p>Center coordinates of the radial average (xc, yc)-&gt;(col, row).</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>radius</code> <code>ndarray</code> <p>Radial axis in pixels.</p> <code>intensity</code> <code>ndarray</code> <p>Integrated intensity normalized by the number of valid pixels.</p> Source code in <code>bblib/utils.py</code> <pre><code>def azimuthal_average_fast(\n    data: np.ndarray, center: tuple = None, mask: np.ndarray = None\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Returns intensity over radius, where intensity is the mean per integer radius.\n    Improve performance.\n\n    Args:\n        data (np.ndarray): Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.\n        center (tuple): Center coordinates of the radial average (xc, yc)-&gt;(col, row).\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n\n    Returns:\n        radius (np.ndarray): Radial axis in pixels.\n        intensity (np.ndarray): Integrated intensity normalized by the number of valid pixels.\n    \"\"\"\n    a, b = data.shape\n    if center is None:\n        center = (b / 2, a / 2)\n\n    if mask is None:\n        mask = np.ones((a, b), dtype=bool)\n    else:\n        mask = mask.astype(bool, copy=False)\n\n    Rint, maxr = _precompute_rbins(data.shape, (float(center[0]), float(center[1])))\n\n    m = mask.ravel()\n    rr = Rint.ravel()[m]\n    vals = data.ravel()[m]\n\n    sums, counts = _radial_reduce(vals, rr, maxr)\n\n    with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n        prof = sums / np.maximum(counts, 1)\n\n    radius = np.arange(prof.size, dtype=np.int32)\n    return radius, prof\n</code></pre>"},{"location":"reference/utils/#bblib.utils.center_of_mass","title":"<code>center_of_mass(data, mask=None)</code>","text":"<p>Adapted from Robert B\u00fccker work on diffractem (https://github.com/robertbuecker/diffractem/tree/master) B\u00fccker, R., Hogan-Lamarre, P., Mehrabi, P. et al. Serial protein crystallography in an electron microscope. Nat Commun 11, 996 (2020). https://doi.org/10.1038/s41467-020-14793-0</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.</p> required <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>xc</code> <code>int</code> <p>Coordinate of the diffraction center in x, such that the image center corresponds to data [yc, xc].</p> <code>yc</code> <code>int</code> <p>Coordinate of the diffraction center in y, such that the image center corresponds to data [yc, xc].</p> Source code in <code>bblib/utils.py</code> <pre><code>def center_of_mass(data: np.ndarray, mask: np.ndarray = None) -&gt; list[int]:\n    \"\"\"\n    Adapted from Robert B\u00fccker work on diffractem (https://github.com/robertbuecker/diffractem/tree/master)\n    B\u00fccker, R., Hogan-Lamarre, P., Mehrabi, P. et al. Serial protein crystallography in an electron microscope. Nat Commun 11, 996 (2020). https://doi.org/10.1038/s41467-020-14793-0\n\n    Args:\n        data (np.ndarray): Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n\n    Returns:\n        xc (int): Coordinate of the diffraction center in x, such that the image center corresponds to data [yc, xc].\n        yc (int): Coordinate of the diffraction center in y, such that the image center corresponds to data [yc, xc].\n    \"\"\"\n\n    if mask is None:\n        mask = np.ones_like(data)\n    data = data * mask\n    indexes = np.where(data &gt; 0)\n    if np.sum(data[indexes]) &gt; 1e-7:\n        xc = np.sum(data[indexes] * indexes[1]) / np.sum(data[indexes])\n        yc = np.sum(data[indexes] * indexes[0]) / np.sum(data[indexes])\n    else:\n        xc = -1\n        yc = -1\n\n    if np.isnan(xc) or np.isnan(yc):\n        xc = -1\n        yc = -1\n\n    return [xc, yc]\n</code></pre>"},{"location":"reference/utils/#bblib.utils.circle_mask","title":"<code>circle_mask(data, center, radius)</code>","text":"<p>Make a circular mask for the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image in which mask will be shaped.</p> required <code>radius</code> <code>int</code> <p>Outer radius of the mask, in pixels.</p> required <p>Returns:</p> Name Type Description <code>mask</code> <code>ndarray</code> <p>Mask array containg zeros (pixels to be masked) and ones (valid pixels).</p> Source code in <code>bblib/utils.py</code> <pre><code>def circle_mask(data: np.ndarray, center: tuple, radius: int) -&gt; np.ndarray:\n    \"\"\"\n    Make a circular mask for the data.\n\n    Args:\n        data (np.ndarray): Image in which mask will be shaped.\n        radius (int): Outer radius of the mask, in pixels.\n\n    Returns:\n        mask (np.ndarray): Mask array containg zeros (pixels to be masked) and ones (valid pixels).\n    \"\"\"\n\n    a = data.shape[0]\n    b = data.shape[1]\n\n    [X, Y] = np.meshgrid(np.arange(b) - center[0], np.arange(a) - center[1])\n    R = np.sqrt(np.square(X) + np.square(Y))\n    return (np.greater(R, radius)).astype(np.int32)\n</code></pre>"},{"location":"reference/utils/#bblib.utils.correct_polarization","title":"<code>correct_polarization(x, y, dist, data, mask, polarization_axis='x', p=0.99)</code>","text":"<p>Correct data for polarisation effect, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234 Acknowledgements: Oleksandr Yefanov, Marina Galchenkova</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.</p> required <code>y</code> <code>ndarray</code> <p>Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.</p> required <code>dist</code> <code>float</code> <p>z distance coordinates of the detector position in pixels.</p> required <code>data</code> <code>ndarray</code> <p>Raw data frame in which polarization correction will be applied.</p> required <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> required <code>p</code> <code>float</code> <p>Polarization degree.</p> <code>0.99</code> <p>Returns:     corrected_data (np.ndarray): Corrected data frame for polarization effect.     pol (np.ndarray): Polarization array for polarization correction.</p> Source code in <code>bblib/utils.py</code> <pre><code>def correct_polarization(\n    x: np.ndarray,\n    y: np.ndarray,\n    dist: float,\n    data: np.ndarray,\n    mask: np.ndarray,\n    polarization_axis: str = \"x\",\n    p: float = 0.99,\n) -&gt; np.ndarray:\n    \"\"\"\n    Correct data for polarisation effect, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234\n    Acknowledgements: Oleksandr Yefanov, Marina Galchenkova\n\n    Args:\n        x (np.ndarray): Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.\n        y (np.ndarray): Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.\n        dist (float): z distance coordinates of the detector position in pixels.\n        data (np.ndarray): Raw data frame in which polarization correction will be applied.\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n        p (float): Polarization degree.\n    Returns:\n        corrected_data (np.ndarray): Corrected data frame for polarization effect.\n        pol (np.ndarray): Polarization array for polarization correction.\n    \"\"\"\n\n    mask = mask.astype(bool)\n    mask = mask.flatten()\n    intensity = np.reshape(data.copy(), len(mask))\n    pol = mask.copy().astype(np.float32)\n    if polarization_axis == \"x\":\n        pol = make_polarization_array(pol, x.flatten(), y.flatten(), dist, p)\n    elif polarization_axis == \"y\":\n        pol = make_polarization_array(pol, x.flatten(), y.flatten(), dist, 1 - p)\n    else:\n        raise ValueError(\"Unreconized polarization axis. Options available are x or y.\")\n\n    intensity = intensity / pol\n    return intensity.reshape(data.shape), pol.reshape(data.shape)\n</code></pre>"},{"location":"reference/utils/#bblib.utils.fsss_to_xy","title":"<code>fsss_to_xy(point, m)</code>","text":"<p>Transforms from the fast-scan/slow-scan basis to the x/y basis.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>tuple</code> <p>Coordinates in the fast-scan/slow-scan basis (ss,fs).</p> required <code>m</code> <code>list</code> <p>A 2x2 transformation matrix.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>The corresponding (x, y) coordinates.</p> Source code in <code>bblib/utils.py</code> <pre><code>def fsss_to_xy(point: tuple, m: list) -&gt; tuple:\n    \"\"\"\n    Transforms from the fast-scan/slow-scan basis to the x/y basis.\n\n    Args:\n        point (tuple): Coordinates in the fast-scan/slow-scan basis (ss,fs).\n        m (list): A 2x2 transformation matrix.\n\n    Returns:\n        tuple: The corresponding (x, y) coordinates.\n    \"\"\"\n\n    d = m[0][0] * m[1][1] - m[0][1] * m[1][0]\n    ss = point[0] + 1\n    fs = point[1] + 1\n    x = int((m[1][1] / d) * fs - (m[0][1] / d) * ss)\n    y = int(-(m[1][0] / d) * fs + (m[0][0] / d) * ss)\n    return x, y\n</code></pre>"},{"location":"reference/utils/#bblib.utils.gaussian_lin","title":"<code>gaussian_lin(x, a, x0, sigma, m, n)</code>","text":"<p>Gaussian function summed to a linear function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-axis.</p> required <code>a</code> <code>float</code> <p>Amplitude of the Gaussian.</p> required <code>x0</code> <code>float</code> <p>Average of the Gaussian.</p> required <code>sigma</code> <code>float</code> <p>Standard deviation of the Gaussian.</p> required <code>m</code> <code>float</code> <p>Angular coefficient.</p> required <code>n</code> <code>float</code> <p>Linear coefficient.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray</code> <p>y-axis.</p> Source code in <code>bblib/utils.py</code> <pre><code>def gaussian_lin(\n    x: np.ndarray, a: float, x0: float, sigma: float, m: float, n: float\n) -&gt; np.ndarray:\n    \"\"\"\n    Gaussian function summed to a linear function.\n\n    Args:\n        x (np.ndarray): x-axis.\n        a (float): Amplitude of the Gaussian.\n        x0 (float): Average of the Gaussian.\n        sigma (float): Standard deviation of the Gaussian.\n        m: Angular coefficient.\n        n: Linear coefficient.\n\n    Returns:\n        y (np.ndarray): y-axis.\n    \"\"\"\n    return m * x + n + a * exp(-((x - x0) ** 2) / (2 * sigma**2))\n</code></pre>"},{"location":"reference/utils/#bblib.utils.get_fwhm_map_min_from_projection","title":"<code>get_fwhm_map_min_from_projection(lines, output_folder, label, pixel_step, plots_flag)</code>","text":"<p>Open FWHM grid search optmization plot, then fit the projection in both axis to get the point of minimum FWHM of the azimuthal average.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list</code> <p>Output of grid search for FWHM optmization, each line must contain a values of xc,yc,fwhm,r_square.</p> required <code>output_folder</code> <code>str</code> <p>Path to the folder where plots are saved.</p> required <code>label</code> <code>str</code> <p>Plots filename label.</p> required <code>pixel_step</code> <code>str</code> <p>Step size between grid points in pixels.</p> required <code>plots_flag</code> <code>bool</code> <p>If True, plots can be generated.</p> required <p>Returns:</p> Name Type Description <code>center</code> <code>list</code> <p>Coordinates of the center of the diffraction pattern in x and y.</p> Source code in <code>bblib/utils.py</code> <pre><code>def get_fwhm_map_min_from_projection(\n    lines: list, output_folder: str, label: str, pixel_step: int, plots_flag: bool\n) -&gt; tuple:\n    \"\"\"\n    Open FWHM grid search optmization plot, then fit the projection in both axis to get the point of minimum FWHM of the azimuthal average.\n\n    Args:\n        lines (list): Output of grid search for FWHM optmization, each line must contain a values of xc,yc,fwhm,r_square.\n        output_folder (str): Path to the folder where plots are saved.\n        label (str): Plots filename label.\n        pixel_step (str): Step size between grid points in pixels.\n        plots_flag (bool): If True, plots can be generated.\n\n    Returns:\n        center (list): Coordinates of the center of the diffraction pattern in x and y.\n    \"\"\"\n    n = int(math.sqrt(len(lines)))\n\n    merged_dict = {}\n    for dictionary in lines[:]:\n        for key, value in dictionary.items():\n            if key in merged_dict:\n                merged_dict[key].append(value)\n            else:\n                merged_dict[key] = [value]\n\n    # Extract x, y, and z from merged_dict\n\n    x_grid = np.array(merged_dict[\"xc\"], dtype=np.int16).reshape((n, n))\n    y_grid = np.array(merged_dict[\"yc\"], dtype=np.int16).reshape((n, n))\n    z_grid = np.array(merged_dict[\"fwhm\"], dtype=np.float32).reshape((n, n))\n    r_grid = np.array(merged_dict[\"r_square\"], dtype=np.float32).reshape((n, n))\n    z_grid = np.nan_to_num(z_grid)\n    r_grid = np.nan_to_num(r_grid)\n\n    proj_x = np.mean(z_grid, axis=1)\n    proj_y = np.mean(z_grid, axis=0)\n\n    x_vals = np.arange(np.min(x_grid), np.max(x_grid) + pixel_step, pixel_step)\n    y_vals = np.arange(np.min(y_grid), np.max(y_grid) + pixel_step, pixel_step)\n\n    try:\n        xc = x_vals[np.argmin(proj_x)]\n        yc = y_vals[np.argmin(proj_y)]\n    except (ValueError, IndexError):\n        xc = -1.0\n        yc = -1.0\n\n    if plots_flag:\n        # Create a figure with three subplots\n        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(10, 10))\n        pos1 = ax1.imshow(z_grid, cmap=\"rainbow\")\n\n        n = z_grid.shape[0]\n        step = 2\n\n        ax1.set_xticks(np.arange(0, n, step, dtype=int))\n        ax1.set_yticks(np.arange(0, n, step, dtype=int))\n        ax1.set_xticklabels(\n            np.arange(x_vals[0], x_vals[-1] + 1, step, dtype=int), rotation=45\n        )\n        ax1.set_yticklabels(np.arange(y_vals[0], y_vals[-1] + 1, step, dtype=int))\n\n        ax1.set_ylabel(\"yc [px]\")\n        ax1.set_xlabel(\"xc [px]\")\n        ax1.set_title(\"FWHM\")\n\n        pos2 = ax2.imshow(r_grid, cmap=\"rainbow\")\n        ax2.set_xticks(np.arange(0, n, step, dtype=int))\n        ax2.set_yticks(np.arange(0, n, step, dtype=int))\n        ax2.set_xticklabels(\n            np.arange(x_vals[0], x_vals[-1] + 1, step, dtype=int), rotation=45\n        )\n        ax2.set_yticklabels(np.arange(y_vals[0], y_vals[-1] + 1, step, dtype=int))\n\n        ax2.set_ylabel(\"yc [px]\")\n        ax2.set_xlabel(\"xc [px]\")\n        ax2.set_title(\"R\u00b2\")\n\n        ax3.scatter(x_vals, proj_x, color=\"b\")\n        ax3.scatter(xc, proj_x[np.argmin(proj_x)], color=\"r\", label=f\"xc: {xc}\")\n        ax3.set_ylabel(\"Average FWHM\")\n        ax3.set_xlabel(\"xc [px]\")\n        ax3.set_title(\"FWHM projection in x\")\n        ax3.legend()\n        ax4.scatter(y_vals, proj_y, color=\"b\")\n        ax4.scatter(yc, proj_y[np.argmin(proj_y)], color=\"r\", label=f\"yc: {yc}\")\n        ax4.set_ylabel(\"Average FWHM\")\n        ax4.set_xlabel(\"yc [px]\")\n        ax4.set_title(\"FWHM projection in y\")\n        ax4.legend()\n        fig.colorbar(pos1, ax=ax1, shrink=0.6)\n        fig.colorbar(pos2, ax=ax2, shrink=0.6)\n\n        path = pathlib.Path(f\"{output_folder}/fwhm_map/\")\n        path.mkdir(parents=True, exist_ok=True)\n        plt.savefig(f\"{output_folder}/fwhm_map/{label}.png\")\n        plt.close()\n\n    if int(np.sum(proj_y)) == 0 or int(np.sum(proj_x)) == 0:\n        xc = -1\n        yc = -1\n\n    return [xc, yc]\n</code></pre>"},{"location":"reference/utils/#bblib.utils.make_polarization_array","title":"<code>make_polarization_array(pol, cox, coy, detdist, poldegree)</code>","text":"<p>Create the polarization array for horizontal polarization correction, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234 Acknowledgements: Oleksandr Yefanov, Marina Galchenkova</p> <p>Parameters:</p> Name Type Description Default <code>pol</code> <code>ndarray</code> <p>An array where polarization array will be built based on its shape. Mask shape is the same size of data. Unvalid pixels (values containing 0) will be skipped from calculation and put 1.</p> required <code>cox</code> <code>ndarray</code> <p>Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.</p> required <code>coy</code> <code>ndarray</code> <p>Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.</p> required <code>detdist</code> <code>float</code> <p>Detector distance from the sample in meters . The detctor distance will be transformed in pixel units based on Res defined as global parameter.</p> required <code>poldegree</code> <code>float</code> <p>Polarization degree from [0,1]. If the polarization is completely horizontal (along the x-axis), then poldegree equals 1.</p> required <p>Returns:     pol (np.ndarray): Polarization array for polarization correction.</p> Source code in <code>bblib/utils.py</code> <pre><code>def make_polarization_array(\n    pol: np.ndarray, cox: np.ndarray, coy: np.ndarray, detdist: float, poldegree: float\n) -&gt; np.ndarray:\n    \"\"\"\n    Create the polarization array for horizontal polarization correction, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234\n    Acknowledgements: Oleksandr Yefanov, Marina Galchenkova\n\n    Args:\n        pol (np.ndarray): An array where polarization array will be built based on its shape. Mask shape is the same size of data. Unvalid pixels (values containing 0) will be skipped from calculation and put 1.\n        cox (np.ndarray): Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.\n        coy (np.ndarray): Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.\n        detdist (float): Detector distance from the sample in meters . The detctor distance will be transformed in pixel units based on Res defined as global parameter.\n        poldegree (float): Polarization degree from [0,1]. If the polarization is completely horizontal (along the x-axis), then poldegree equals 1.\n    Returns:\n        pol (np.ndarray): Polarization array for polarization correction.\n    \"\"\"\n\n    z = detdist * np.ones(cox.shape[0])\n    valid = np.where(pol == 1)\n\n    pol[valid] = 1 - (\n        (poldegree * (cox[valid] ** 2) + (1 - poldegree) * (coy[valid] ** 2))\n        / (cox[valid] ** 2 + coy[valid] ** 2 + z[valid] ** 2)\n    )\n    pol[np.where(pol == 0)] = 1.0\n\n    return pol\n</code></pre>"},{"location":"reference/utils/#bblib.utils.mask_peaks","title":"<code>mask_peaks(mask, indexes, bragg, n)</code>","text":"<p>Gather coordinates of a box of 1x1 pixels around each point from the indexes list. Bragg flag indicates if the mask returned will contain only bragg peaks regions (bragg =1), no bragg peaks regions (bragg=0), or both (bragg =-1).</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>An array where mask will be built based on its shape. Mask shape is the same size of data.</p> required <code>indexes</code> <code>tuple</code> <p>Bragg peaks coordinates, indexes[0] contains x-coordinates of Bragg peaks and indexes[1] the corresponding y-coordinates.</p> required <code>bragg</code> <code>int</code> <p>Bragg flag, choose between return only peaks, only background or both (bypass masking of peaks).</p> required <code>n</code> <code>int</code> <p>Number of pixels to build a 2*n box around the Bragg peaks.</p> required <p>Returns:</p> Name Type Description <code>surrounding_mask</code> <code>ndarray</code> <p>Corresponding mask according to bragg flag choice. It contains zeros for unvalid pixels and one for valid pixels. Mask shape is the same size of data.</p> Source code in <code>bblib/utils.py</code> <pre><code>def mask_peaks(mask: np.ndarray, indexes: tuple, bragg: int, n: int) -&gt; np.ndarray:\n    \"\"\"\n    Gather coordinates of a box of 1x1 pixels around each point from the indexes list. Bragg flag indicates if the mask returned will contain only bragg peaks regions (bragg =1), no bragg peaks regions (bragg=0), or both (bragg =-1).\n\n    Args:\n        mask (np.ndarray): An array where mask will be built based on its shape. Mask shape is the same size of data.\n        indexes (tuple): Bragg peaks coordinates, indexes[0] contains x-coordinates of Bragg peaks and indexes[1] the corresponding y-coordinates.\n        bragg (int): Bragg flag, choose between return only peaks, only background or both (bypass masking of peaks).\n        n (int): Number of pixels to build a 2*n box around the Bragg peaks.\n\n    Returns:\n        surrounding_mask (np.ndarray): Corresponding mask according to bragg flag choice. It contains zeros for unvalid pixels and one for valid pixels. Mask shape is the same size of data.\n    \"\"\"\n    surrounding_positions = []\n    count = 0\n    for index in zip(indexes[0], indexes[1]):\n        row, col = index\n        for i in range(-n, n + 1):\n            for k in range(-n, n + 1):\n                surrounding_positions.append((row + i, col + k))\n        count += 1\n\n    if bragg == 1:\n        surrounding_mask = np.zeros_like(mask)\n        for pos in surrounding_positions:\n            row, col = pos\n            if 0 &lt;= row &lt; mask.shape[0] and 0 &lt;= col &lt; mask.shape[1]:\n                surrounding_mask[row, col] = 1\n    elif bragg == -1:\n        surrounding_mask = np.ones_like(mask)\n    else:\n        surrounding_mask = np.ones_like(mask)\n        for pos in surrounding_positions:\n            row, col = pos\n            if 0 &lt;= row &lt; mask.shape[0] and 0 &lt;= col &lt; mask.shape[1]:\n                surrounding_mask[row, col] = 0\n\n    return surrounding_mask\n</code></pre>"},{"location":"reference/utils/#bblib.utils.ring_mask","title":"<code>ring_mask(data, center, inner_radius, outer_radius)</code>","text":"<p>Make a ring mask for the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image in which mask will be shaped.</p> required <code>center</code> <code>tuple</code> <p>Center coordinates (xc,yc) of the concentric rings for the mask.</p> required <code>inner_radius</code> <code>int</code> <p>Inner radius of the mask, in pixels.</p> required <code>outer_radius</code> <code>int</code> <p>Outer radius of the mask, in pixels.</p> required <p>Returns:</p> Name Type Description <code>mask</code> <code>ndarray</code> <p>Mask array containg zeros (pixels to be masked) and ones (valid pixels).</p> Source code in <code>bblib/utils.py</code> <pre><code>def ring_mask(\n    data: np.ndarray, center: tuple, inner_radius: int, outer_radius: int\n) -&gt; np.ndarray:\n    \"\"\"\n    Make a ring mask for the data.\n\n    Args:\n        data (np.ndarray): Image in which mask will be shaped.\n        center (tuple): Center coordinates (xc,yc) of the concentric rings for the mask.\n        inner_radius (int): Inner radius of the mask, in pixels.\n        outer_radius (int): Outer radius of the mask, in pixels.\n\n    Returns:\n        mask (np.ndarray): Mask array containg zeros (pixels to be masked) and ones (valid pixels).\n    \"\"\"\n\n    bin_size = bin\n    a = data.shape[0]\n    b = data.shape[1]\n    [X, Y] = np.meshgrid(np.arange(b) - center[0], np.arange(a) - center[1])\n    R = np.sqrt(np.square(X) + np.square(Y))\n    bin_size = outer_radius - inner_radius\n    return np.greater(R, outer_radius - bin_size) &amp; np.less(R, outer_radius + bin_size)\n</code></pre>"},{"location":"reference/utils/#bblib.utils.visualize_single_panel","title":"<code>visualize_single_panel(data, transformation_matrix, ss_in_rows)</code>","text":"<p>Creates a visulization array for single panel detectors after applying the detector geometry.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image in which mask will be shaped</p> required <code>transformation_matrix</code> <code>ndarray</code> <p>A 2x2 transformation matrix used to map from fast-scan/slow-scan to x/y coordinates.</p> required <code>ss_in_rows</code> <code>bool</code> <p>If True, the slow-scan axis is mapped to rows; otherwise to columns.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed visualization array.</p> Source code in <code>bblib/utils.py</code> <pre><code>def visualize_single_panel(\n    data: np.ndarray, transformation_matrix: np.ndarray, ss_in_rows: bool\n) -&gt; np.ndarray:\n    \"\"\"\n    Creates a visulization array for single panel detectors after applying the detector geometry.\n\n    Args:\n        data (np.ndarray): Image in which mask will be shaped\n        transformation_matrix (np.ndarray): A 2x2 transformation matrix used to map from fast-scan/slow-scan to x/y coordinates.\n        ss_in_rows (bool): If True, the slow-scan axis is mapped to rows; otherwise to columns.\n\n    Returns:\n        np.ndarray: The transformed visualization array.\n    \"\"\"\n    visual_data = np.full((2 * max(data.shape) + 1, 2 * max(data.shape) + 1), np.nan)\n\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            point = (i, j) if ss_in_rows else (j, i)\n            xy_j, xy_i = fsss_to_xy(point, transformation_matrix)\n            visual_data[xy_i][xy_j] = data[i][j]\n\n    non_nan_indices = np.where(~np.isnan(visual_data))\n    min_row_index, min_col_index = np.min(non_nan_indices, axis=1)\n    max_row_index, max_col_index = np.max(non_nan_indices, axis=1)\n\n    return visual_data[\n        min_row_index : max_row_index + 1, min_col_index : max_col_index + 1\n    ]\n</code></pre>"},{"location":"tutorial/","title":"bblib tutorial","text":"<p>This tutorial provides examples of how to use bblib centering methods.</p> <p>The tutorial repository contains Jupyter notebooks and the data used in this tutorial.</p> <p>In the folder <code>bblib_tutorial/data</code> you will find the data required to run the centering methods of <code>bblib</code>, as well as their corresponding masks in the <code>bblib_tutorial/masks</code> folder, and CrystFEL geometry files in the <code>bblib_tutorial/geoms</code> folder.</p> <p>Remember to set the <code>mask_file</code> path in the geometry files (*.geom) to the corresponding path on your system.</p> <p>This tutorial runs on bblib version &gt;= 3.1.0.</p>"},{"location":"tutorial/#installation","title":"Installation","text":"<p>To run this tutorial, you will need Python 3.10.</p> <ul> <li> <p>In the terminal, type the following command: <pre><code>git clone https://github.com/anananacr/bblib_tutorial.git\n</code></pre></p> </li> <li> <p>Navigate into the <code>bblib_tutorial</code> folder:</p> </li> </ul> <pre><code>cd bblib_tutorial\n</code></pre> <ul> <li>Install the requirements:</li> </ul> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"tutorial/center_of_mass/center_of_mass/","title":"Center of mass centering","text":"<pre><code>import h5py\nimport hdf5plugin\nimport numpy as np\nimport fabio\nimport matplotlib.pyplot as plt\nimport om.lib.geometry as geometry\n\nfrom bblib.methods import CenterOfMass\nfrom bblib.models import PF8Info, PF8\nfrom bblib.utils import visualize_single_panel\n</code></pre> <p>Set here the absolute path to bblib_tutorial</p> <pre><code>tutorial_path=\"/path/to/bblib_tutorial\"\n</code></pre> <p>You will need to set the tutorial_path on the mask_file parameter in the geometry files cointaned in the bblib_tutorial/geoms folder</p> <pre><code>config = {\n    \"plots_flag\": True,\n    \"pf8\": {\n        \"max_num_peaks\": 10000,\n        \"adc_threshold\": 10,\n        \"minimum_snr\": 4,\n        \"min_pixel_count\": 2,\n        \"max_pixel_count\": 200,\n        \"local_bg_radius\": 3,\n        \"min_res\": 0,\n        \"max_res\": 2000\n        },\n    \"bragg_peaks_for_center_of_mass_calculation\": 0,\n    \"pixels_for_mask_of_bragg_peaks\": 2\n}\n</code></pre> <pre><code>PF8Config=PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"]\n    )\n</code></pre> <p>First, open your raw file:</p> <pre><code>cbf_file=f\"{tutorial_path}/example/data/chipD_001_00111.cbf\"\ndata = fabio.open(cbf_file).data\n</code></pre> <p>Indicate the geometry filename that describes the initial detector geometry according to CrystFEL:</p> <pre><code>geometry_filename=f\"{tutorial_path}/example/geoms/pilatus6M.geom\"\n</code></pre> <p>Please, check if the geometry file points to the correct path of the mask in your system. If not, set the correct path to the mask in the geometry file.</p> <pre><code>with open(geometry_filename, \"r\") as f:\n    lines = f.readlines()\nprint(lines[5])\n</code></pre> <p>If you want to check and have a look how the data looks like:</p> <pre><code>hdf5_file=f\"{tutorial_path}/example/masks/mask_chipD_001_00111.h5\"\nf = h5py.File(hdf5_file, \"r\")\nmask = np.array(f[\"data/data\"])\nf.close()\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(data*mask, vmin=0,vmax=10)\nplt.show()\n</code></pre>          Figure"},{"location":"tutorial/center_of_mass/center_of_mass/#set-detector-geometry","title":"Set detector geometry","text":"<pre><code>PF8Config.set_geometry_from_file(geometry_filename)\n</code></pre> <p>Visualize multi panels detector</p> <pre><code># Not the case here, so I am commenting this\n#data_visualize = geometry.DataVisualizer(pixel_maps=PF8Config.pixel_maps)\n#visual_data = data_visualize.visualize_data(data=data * mask)\n#plt.close()\n#%matplotlib widget\n#plt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <p>Visualize single panel detector</p> <pre><code>visual_data = visualize_single_panel(data*mask, PF8Config.transformation_matrix_for_visualization, PF8Config.ss_in_rows)\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <pre><code>&lt;matplotlib.image.AxesImage at 0x15d12bb20&gt;\n</code></pre>          Figure"},{"location":"tutorial/center_of_mass/center_of_mass/#run-the-centering","title":"Run the centering","text":"<p>Dictionaries config and PF8Config ready for centering:</p> <p>If you want to save intermediate steps plots, set the path as root_path/run_label/*/file_label_frame_index.png</p> <pre><code>plots_info={\n    \"filename\": \"chip_D_111\",\n    \"folder_name\": \"fakp\",\n    \"root_path\": f\"{tutorial_path}/example\",\n    \"value_auto\": True,\n    \"axis_lim_auto\": True,\n    \"color_map\": \"viridis\",\n    \"marker_size\": 20\n}\n</code></pre> <pre><code>center_of_mass_method = CenterOfMass(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\n</code></pre> <pre><code>center_coordinates_from_center_of_mass = center_of_mass_method(\n                        data = data\n                    )\n</code></pre> <p>Print the final result:</p> <pre><code>center_coordinates_from_center_of_mass\n</code></pre> <pre><code>[1249.4757747245367, 1188.7620415459703]\n</code></pre> <pre><code>PF8Config.detector_center_from_geom\n</code></pre> <pre><code>[1252.864, 1176.4808]\n</code></pre> <pre><code>beam_position_shift = [center_coordinates_from_center_of_mass[x] - PF8Config.detector_center_from_geom[x] for x in range(2)]\n</code></pre> <pre><code>detector_shift_in_mm = [np.round(-1 * x *1e3 / PF8Config.pixel_resolution, 4) for x in beam_position_shift]\n</code></pre> <pre><code>detector_shift_in_mm\n</code></pre> <pre><code>[0.5828, -2.1124]\n</code></pre>"},{"location":"tutorial/circle_detection/circle_detection/","title":"Circle detection centering","text":"<pre><code>import h5py\nimport hdf5plugin\nimport numpy as np\nimport fabio\nimport matplotlib.pyplot as plt\nimport om.lib.geometry as geometry\n\nfrom bblib.methods import CircleDetection\nfrom bblib.models import PF8Info, PF8\nfrom bblib.utils import visualize_single_panel\n</code></pre> <p>Set here the absolute path to bblib_tutorial</p> <pre><code>tutorial_path=\"/path/to/bblib_tutorial\"\n</code></pre> <p>You will need to set the tutorial_path on the mask_file parameter in the geometry files cointaned in the bblib_tutorial/geoms folder</p> <pre><code>config = {\n    \"plots_flag\": True,\n    \"pf8\": {\n        \"max_num_peaks\": 10000,\n        \"adc_threshold\": 10,\n        \"minimum_snr\": 5,\n        \"min_pixel_count\": 2,\n        \"max_pixel_count\": 200,\n        \"local_bg_radius\": 3,\n        \"min_res\": 0,\n        \"max_res\": 1200\n        },\n    \"peak_region\":{\n        \"min\": 60,\n        \"max\": 80\n        },\n    \"canny\":{\n        \"sigma\": 3,\n        \"low_threshold\": 0.9,\n        \"high_threshold\": 0.99\n        },\n    \"hough_rank\": 1,\n    \"pixels_for_mask_of_bragg_peaks\": 2\n}\n</code></pre> <pre><code>PF8Config=PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"]\n    )\n</code></pre> <p>First, open your raw file:</p> <pre><code>hdf5_file=f\"{tutorial_path}/example/data/lyso_test_data_000014.h5\"\nf = h5py.File(hdf5_file, \"r\")\ndata = np.array(f[\"entry/data/data\"][4], dtype=np.int32)\nf.close()\n</code></pre> <p>Indicate the geometry filename that describes the initial detector geometry according to CrystFEL:</p> <pre><code>geometry_filename=f\"{tutorial_path}/example/geoms/eiger500k.geom\"\n</code></pre> <p>Please, check if the geometry file points to the correct path of the mask in your system. If not, set the correct path to the mask in the geometry file.</p> <pre><code>with open(geometry_filename, \"r\") as f:\n    lines = f.readlines()\nprint(lines[13])\n</code></pre> <p>If you want to check and have a look how the data looks like:</p> <pre><code>hdf5_file=f\"{tutorial_path}/example/masks/mask_lyso_test_data_000014.h5\"\nf = h5py.File(hdf5_file, \"r\")\nmask = np.array(f[\"data/data\"])\nf.close()\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(data*mask, vmin=0,vmax=10)\nplt.show()\n</code></pre>          Figure"},{"location":"tutorial/circle_detection/circle_detection/#set-detector-geometry","title":"Set detector geometry","text":"<pre><code>PF8Config.set_geometry_from_file(geometry_filename)\n</code></pre> <p>Visualize multi panels detector</p> <pre><code># Not the case here, so I am commenting this\n#data_visualize = geometry.DataVisualizer(pixel_maps=PF8Config.pixel_maps)\n#visual_data = data_visualize.visualize_data(data=data * mask)\n#plt.close()\n#%matplotlib widget\n#plt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <p>Visualize single panel detector</p> <pre><code>visual_data = visualize_single_panel(data*mask, PF8Config.transformation_matrix_for_visualization, PF8Config.ss_in_rows)\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <pre><code>&lt;matplotlib.image.AxesImage at 0x13f524670&gt;\n</code></pre>          Figure"},{"location":"tutorial/circle_detection/circle_detection/#run-the-centering","title":"Run the centering","text":"<p>Dictionaries config and PF8Config ready for centering:</p> <p>If you want to save intermediate steps plots, set the path as root_path/run_label/*/file_label_frame_index.png</p> <pre><code>plots_info={\n    \"filename\": \"lyso_2\",\n    \"folder_name\": \"beam_sweeping_lyso\",\n    \"root_path\": f\"{tutorial_path}/example\",\n    \"value_auto\": True,\n    \"axis_lim_auto\": True,\n    \"color_map\": \"viridis\",\n    \"marker_size\":20\n}\n</code></pre> <pre><code>circle_detection_method = CircleDetection(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\n</code></pre> <pre><code>center_coordinates_from_circle_detection = circle_detection_method(\n                        data = data\n                    )\n</code></pre> <p>Print the final result:</p> <pre><code>center_coordinates_from_circle_detection\n</code></pre> <pre><code>[401, 631]\n</code></pre> <pre><code>PF8Config.detector_center_from_geom\n</code></pre> <pre><code>[401.5, 656.5]\n</code></pre> <pre><code>beam_position_shift = [center_coordinates_from_circle_detection[x] - PF8Config.detector_center_from_geom[x] for x in range(2)]\n</code></pre> <pre><code>detector_shift_in_mm = [np.round(-1 * x *1e3 / PF8Config.pixel_resolution, 4) for x in beam_position_shift]\n</code></pre> <pre><code>detector_shift_in_mm\n</code></pre> <pre><code>[0.0375, 1.9125]\n</code></pre>"},{"location":"tutorial/friedel_pairs/friedel_pairs/","title":"Friedel Pairs centering","text":"<pre><code>import h5py\nimport hdf5plugin\nimport numpy as np\nimport fabio\nimport matplotlib.pyplot as plt\nimport om.lib.geometry as geometry\n\nfrom bblib.methods import FriedelPairs\nfrom bblib.models import PF8Info, PF8\nfrom bblib.utils import visualize_single_panel\n</code></pre> <p>Set here the absolute path to bblib_tutorial</p> <pre><code>tutorial_path=\"/path/to/bblib_tutorial\"\n</code></pre> <p>You will need to set the tutorial_path on the mask_file parameter in the geometry files cointaned in the bblib_tutorial/geoms folder</p> <pre><code>config = {\n    \"plots_flag\": True,\n    \"search_radius\": 4,\n    \"pf8\": {\n        \"max_num_peaks\": 10000,\n        \"adc_threshold\": 10,\n        \"minimum_snr\": 5,\n        \"min_pixel_count\": 2,\n        \"max_pixel_count\": 200,\n        \"local_bg_radius\": 3,\n        \"min_res\": 0,\n        \"max_res\": 1200\n        },\n    \"polarization\": {\n        \"apply_polarization_correction\": True,\n        \"axis\":\"x\",\n        \"value\":0.99\n        }\n}\n</code></pre> <pre><code>PF8Config=PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"]\n    )\n</code></pre> <p>First, open your raw file:</p> <pre><code>hdf5_file=f\"{tutorial_path}/example/data/lyso_test_data_000014.h5\"\nf = h5py.File(hdf5_file, \"r\")\ndata = np.array(f[\"entry/data/data\"][4], dtype=np.int32)\nf.close()\n</code></pre> <p>Indicate the geometry filename that describes the initial detector geometry according to CrystFEL:</p> <pre><code>geometry_filename=f\"{tutorial_path}/example/geoms/eiger500k.geom\"\n</code></pre> <p>Please, check if the geometry file points to the correct path of the mask in your system. If not, set the correct path to the mask in the geometry file.</p> <pre><code>with open(geometry_filename, \"r\") as f:\n    lines = f.readlines()\nprint(lines[13])\n</code></pre> <p>If you want to check and have a look how the data looks like:</p> <pre><code>hdf5_file=f\"{tutorial_path}/example/masks/mask_lyso_test_data_000014.h5\"\nf = h5py.File(hdf5_file, \"r\")\nmask = np.array(f[\"data/data\"])\nf.close()\n</code></pre> <pre><code>%matplotlib widget\nplt.imshow(data*mask, vmin=0,vmax=10)\nplt.show()\n</code></pre>          Figure"},{"location":"tutorial/friedel_pairs/friedel_pairs/#set-detector-geometry","title":"Set detector geometry","text":"<pre><code>PF8Config.set_geometry_from_file(geometry_filename)\n</code></pre> <p>Visualize multi panels detector</p> <pre><code># Not the case here, so I am commenting this\n#data_visualize = geometry.DataVisualizer(pixel_maps=PF8Config.pixel_maps)\n#visual_data = data_visualize.visualize_data(data=data * mask)\n#plt.close()\n#%matplotlib widget\n#plt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <p>Visualize single panel detector</p> <pre><code>visual_data = visualize_single_panel(data*mask, PF8Config.transformation_matrix_for_visualization, PF8Config.ss_in_rows)\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <pre><code>&lt;matplotlib.image.AxesImage at 0x1475244c0&gt;\n</code></pre>          Figure"},{"location":"tutorial/friedel_pairs/friedel_pairs/#run-the-centering","title":"Run the centering","text":"<p>Dictionaries config and PF8Config ready for centering:</p> <p>For the FriedelPairs method an initial_guess need to be passed, set here the coordinates in x and y of the initial guess for the center after setting the detector geometry:</p> <pre><code>initial_guess=[401,631]\n</code></pre> <p>If you want to save intermediate steps plots, set the path as root_path/run_label/*/file_label_frame_index.png</p> <pre><code>plots_info={\n    \"filename\": \"lyso_2\",\n    \"folder_name\": \"beam_sweeping_lyso\",\n    \"root_path\": f\"{tutorial_path}/example\",\n    \"value_auto\": True,\n    \"axis_lim_auto\": True,\n    \"color_map\": \"viridis\",\n    \"marker_size\": 20\n}\n</code></pre> <pre><code>friedel_pairs_method = FriedelPairs(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\n</code></pre> <pre><code>center_coordinates_from_friedel_pairs = friedel_pairs_method(\n                        data = data, initial_guess= initial_guess\n                    )\n</code></pre> <pre><code>--------------  Friedel pairs search --------------\nNumber of Friedel Pairs in frame: 1.0\nPairs list for analysis:\n[((-96.0, 80.0), (-97.0, 79.0)), ((97.0, -79.0), (96.0, -80.0))]\nFriedel pairs position before center correction in pixels:\n[(-96.0, 80.0), (97.0, -79.0)]\nCenter shift in x 0.5\nCenter shift in y 0.5\nFriedel pairs position after center correction in pixels:\n[(-96.5, 79.5), (96.5, -79.5)]\nAll reflections after center correction in pixels:\n[(-391.5, -71.5), (-368.5, 24.5), (-352.5, 76.5), (-349.5, 158.5), (-348.5, 86.5), (-345.5, 259.5), (-340.5, -160.5), (-338.5, -52.5), (-330.5, -326.5), (-314.5, 247.5), (-311.5, -37.5), (-307.5, 239.5), (-302.5, 62.5), (-296.5, -236.5), (-294.5, -163.5), (-289.5, -336.5), (-286.5, 225.5), (-283.5, -78.5), (-271.5, 237.5), (-268.5, 14.5), (-261.5, -120.5), (-257.5, -246.5), (-248.5, -99.5), (-245.5, -34.5), (-239.5, -212.5), (-237.5, -402.5), (-236.5, -94.5), (-236.5, 159.5), (-233.5, 85.5), (-227.5, -75.5), (-228.5, -6.5), (-226.5, -177.5), (-219.5, 122.5), (-215.5, 33.5), (-212.5, 43.5), (-211.5, -110.5), (-208.5, 134.5), (-206.5, -247.5), (-206.5, -56.5), (-200.5, -79.5), (-196.5, 239.5), (-195.5, 170.5), (-194.5, -27.5), (-177.5, -221.5), (-175.5, 31.5), (-175.5, -153.5), (-173.5, 48.5), (-167.5, -318.5), (-167.5, -351.5), (-165.5, -284.5), (-163.5, -166.5), (-163.5, 155.5), (-163.5, 315.5), (-160.5, -260.5), (-148.5, -181.5), (-145.5, -172.5), (-145.5, 16.5), (-142.5, 234.5), (-136.5, 195.5), (-131.5, -150.5), (-129.5, 11.5), (-128.5, 166.5), (-126.5, 278.5), (-123.5, 153.5), (-120.5, 214.5), (-116.5, -565.5), (-112.5, -270.5), (-109.5, 86.5), (-101.5, 277.5), (-96.5, 79.5), (-96.5, 42.5), (-93.5, -193.5), (-85.5, -248.5), (-86.5, 182.5), (-84.5, -223.5), (-80.5, -104.5), (-74.5, 303.5), (-73.5, -181.5), (-67.5, 45.5), (-62.5, -400.5), (67.5, 185.5), (72.5, 365.5), (77.5, 263.5), (79.5, -187.5), (81.5, -144.5), (86.5, -86.5), (94.5, -50.5), (95.5, 3.5), (96.5, -79.5), (100.5, 114.5), (101.5, -69.5), (102.5, 40.5), (105.5, -279.5), (106.5, -61.5), (109.5, -172.5)]\n-- End --\n</code></pre> <p>Print the final result:</p> <pre><code>center_coordinates_from_friedel_pairs\n</code></pre> <pre><code>[401.5, 631.5]\n</code></pre> <pre><code>PF8Config.detector_center_from_geom\n</code></pre> <pre><code>[401.5, 656.5]\n</code></pre> <pre><code>beam_position_shift = [center_coordinates_from_friedel_pairs[x] - PF8Config.detector_center_from_geom[x] for x in range(2)]\n</code></pre> <pre><code>beam_position_shift\n</code></pre> <pre><code>[0.0, -25.0]\n</code></pre> <pre><code>detector_shift_in_mm = [np.round(-1 * x *1e3 / PF8Config.pixel_resolution, 4) for x in beam_position_shift]\n</code></pre> <pre><code>detector_shift_in_mm\n</code></pre> <pre><code>[-0.0, 1.875]\n</code></pre>"},{"location":"tutorial/minimize_peak_fwhm/minimize_peak_fwhm/","title":"Minimize peak FWHM centering","text":"<pre><code>import h5py\nimport hdf5plugin\nimport numpy as np\nimport fabio\nimport matplotlib.pyplot as plt\nimport om.lib.geometry as geometry\n\nfrom bblib.methods import MinimizePeakFWHM\nfrom bblib.models import PF8Info, PF8\nfrom bblib.utils import visualize_single_panel\n</code></pre> <p>Set here the absolute path to bblib_tutorial</p> <pre><code>tutorial_path=\"/path/to/bblib_tutorial\"\n</code></pre> <p>You will need to set the tutorial_path on the mask_file parameter in the geometry files cointaned in the bblib_tutorial/geoms folder</p> <pre><code>config = {\n    \"plots_flag\": True,\n    \"pf8\": {\n        \"max_num_peaks\": 10000,\n        \"adc_threshold\": 10,\n        \"minimum_snr\": 4,\n        \"min_pixel_count\": 2,\n        \"max_pixel_count\": 200,\n        \"local_bg_radius\": 3,\n        \"min_res\": 0,\n        \"max_res\": 2000\n        },\n    \"peak_region\":{\n        \"min\": 200,\n        \"max\": 400\n        },\n    \"grid_search_radius\":10,\n    \"pixels_for_mask_of_bragg_peaks\": 2,\n    \"polarization\": {\n        \"apply_polarization_correction\":True,\n        \"axis\":\"x\",\n        \"value\":0.99\n        }\n}\n</code></pre> <pre><code>PF8Config=PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"]\n    )\n</code></pre> <p>First, open your raw file:</p> <pre><code>cbf_file=f\"{tutorial_path}/example/data/chipD_001_00111.cbf\"\ndata = fabio.open(cbf_file).data\n</code></pre> <p>Indicate the geometry filename that describes the initial detector geometry according to CrystFEL:</p> <pre><code>geometry_filename=f\"{tutorial_path}/example/geoms/pilatus6M.geom\"\n</code></pre> <p>Please, check if the geometry file points to the correct path of the mask in your system. If not, set the correct path to the mask in the geometry file.</p> <pre><code>with open(geometry_filename, \"r\") as f:\n    lines = f.readlines()\nprint(lines[5])\n</code></pre> <p>If you want to check and have a look how the data looks like:</p> <pre><code>hdf5_file=f\"{tutorial_path}/example/masks/mask_chipD_001_00111.h5\"\nf = h5py.File(hdf5_file, \"r\")\nmask = np.array(f[\"data/data\"])\nf.close()\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(data*mask, vmin=0,vmax=10)\nplt.show()\n</code></pre>          Figure"},{"location":"tutorial/minimize_peak_fwhm/minimize_peak_fwhm/#set-detector-geometry","title":"Set detector geometry","text":"<pre><code>PF8Config.set_geometry_from_file(geometry_filename)\n</code></pre> <p>Visualize multi panels detector</p> <pre><code># Not the case here, so I am commenting this\n#data_visualize = geometry.DataVisualizer(pixel_maps=PF8Config.pixel_maps)\n#visual_data = data_visualize.visualize_data(data=data * mask)\n#plt.close()\n#%matplotlib widget\n#plt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <p>Visualize single panel detector</p> <pre><code>visual_data = visualize_single_panel(data*mask, PF8Config.transformation_matrix_for_visualization, PF8Config.ss_in_rows)\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <pre><code>&lt;matplotlib.image.AxesImage at 0x135c2fe80&gt;\n</code></pre>          Figure"},{"location":"tutorial/minimize_peak_fwhm/minimize_peak_fwhm/#run-the-centering","title":"Run the centering","text":"<p>Dictionaries config and PF8Config ready for centering:</p> <p>For the MinimizePeakFWHM method an initial_guess need to be passed, set here the coordinates in x and y of the initial guess for the center after setting the detector geometry:</p> <pre><code>initial_guess=[1250,1150]\n</code></pre> <p>If you want to save intermediate steps plots, set the path as root_path/run_label/*/file_label_frame_index.png</p> <pre><code>plots_info={\n    \"filename\": \"chip_D_111\",\n    \"folder_name\": \"fakp\",\n    \"root_path\": f\"{tutorial_path}/example\",\n    \"value_auto\": True,\n    \"axis_lim_auto\": True,\n    \"color_map\": \"viridis\",\n    \"marker_size\": 20\n}\n</code></pre> <pre><code>minimize_peak_fwhm_method = MinimizePeakFWHM(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\n</code></pre> <pre><code>center_coordinates_from_minimize_peak_fwhm = minimize_peak_fwhm_method(\n                        data = data, initial_guess=initial_guess\n                    )\n</code></pre> <p>Print the final result:</p> <pre><code>center_coordinates_from_minimize_peak_fwhm\n</code></pre> <pre><code>[1252, 1150]\n</code></pre> <pre><code>PF8Config.detector_center_from_geom\n</code></pre> <pre><code>[1252.864, 1176.4808]\n</code></pre> <pre><code>beam_position_shift = [center_coordinates_from_minimize_peak_fwhm[x] - PF8Config.detector_center_from_geom[x] for x in range(2)]\n</code></pre> <pre><code>detector_shift_in_mm = [np.round(-1 * x *1e3 / PF8Config.pixel_resolution, 4) for x in beam_position_shift]\n</code></pre> <pre><code>detector_shift_in_mm\n</code></pre> <pre><code>[0.1486, 4.5547]\n</code></pre>"}]}