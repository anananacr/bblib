{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to the beambusters library documentation!"},{"location":"reference/","title":"About bblib","text":"<p>The beambusters library (bblib) is a library that contains methods to determine the detector center directly from still diffraction patterns collected in serial crystallography experiments.</p> <p> Python 3.10</p>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#bblib.utils","title":"<code>utils</code>","text":""},{"location":"reference/utils/#bblib.utils.azimuthal_average","title":"<code>azimuthal_average(data, center=None, mask=None)</code>","text":"<p>Calculate azimuthal integration of data in relation to the center of the image Adapted from L. P. Ren\u00e9 de Cotret work on scikit-ued (https://github.com/LaurentRDC/scikit-ued/tree/master) L. P. Ren\u00e9 de Cotret, M. R. Otto, M. J. Stern. and B. J. Siwick, An open-source software ecosystem for the interactive exploration of ultrafast electron scattering data, Advanced Structural and Chemical Imaging 4:11 (2018) DOI: 10.1186/s40679-018-0060-y.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.</p> required <code>center</code> <code>tuple</code> <p>Center coordinates of the radial average (xc, yc)-&gt;(col, row).</p> <code>None</code> <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>radius</code> <code>ndarray</code> <p>Radial axis in pixels.</p> <code>intensity</code> <code>ndarray</code> <p>Integrated intensity normalized by the number of valid pixels.</p> Source code in <code>bblib/utils.py</code> <pre><code>def azimuthal_average(\n    data: np.ndarray, center: tuple = None, mask: np.ndarray = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculate azimuthal integration of data in relation to the center of the image\n    Adapted from L. P. Ren\u00e9 de Cotret work on scikit-ued (https://github.com/LaurentRDC/scikit-ued/tree/master)\n    L. P. Ren\u00e9 de Cotret, M. R. Otto, M. J. Stern. and B. J. Siwick, An open-source software ecosystem for the interactive exploration of ultrafast electron scattering data, Advanced Structural and Chemical Imaging 4:11 (2018) DOI: 10.1186/s40679-018-0060-y.\n\n    Args:\n        data (np.ndarray): Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.\n        center (tuple): Center coordinates of the radial average (xc, yc)-&gt;(col, row).\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n\n    Returns:\n        radius (np.ndarray): Radial axis in pixels.\n        intensity (np.ndarray): Integrated intensity normalized by the number of valid pixels.\n    \"\"\"\n    a = data.shape[0]\n    b = data.shape[1]\n    if mask is None:\n        mask = np.zeros((a, b), dtype=bool)\n    else:\n        mask.astype(bool)\n\n    if center is None:\n        center = [b / 2, a / 2]\n    [X, Y] = np.meshgrid(np.arange(b) - center[0], np.arange(a) - center[1])\n    R = np.sqrt(np.square(X) + np.square(Y))\n    Rint = np.rint(R).astype(int)\n\n    valid = mask.flatten()\n    data = data.flatten()\n    Rint = Rint.flatten()\n\n    px_bin = np.bincount(Rint, weights=valid * data)\n    r_bin = np.bincount(Rint, weights=valid)\n    radius = np.arange(0, r_bin.size)\n    # Replace by one if r_bin is zero for division\n    np.maximum(r_bin, 1, out=r_bin)\n\n    return radius, px_bin / r_bin\n</code></pre>"},{"location":"reference/utils/#bblib.utils.center_of_mass","title":"<code>center_of_mass(data, mask=None)</code>","text":"<p>Adapted from Robert B\u00fccker work on diffractem (https://github.com/robertbuecker/diffractem/tree/master) B\u00fccker, R., Hogan-Lamarre, P., Mehrabi, P. et al. Serial protein crystallography in an electron microscope. Nat Commun 11, 996 (2020). https://doi.org/10.1038/s41467-020-14793-0</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.</p> required <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>xc</code> <code>int</code> <p>Coordinate of the diffraction center in x, such that the image center corresponds to data [yc, xc].</p> <code>yc</code> <code>int</code> <p>Coordinate of the diffraction center in y, such that the image center corresponds to data [yc, xc].</p> Source code in <code>bblib/utils.py</code> <pre><code>def center_of_mass(data: np.ndarray, mask: np.ndarray = None) -&gt; list[int]:\n    \"\"\"\n    Adapted from Robert B\u00fccker work on diffractem (https://github.com/robertbuecker/diffractem/tree/master)\n    B\u00fccker, R., Hogan-Lamarre, P., Mehrabi, P. et al. Serial protein crystallography in an electron microscope. Nat Commun 11, 996 (2020). https://doi.org/10.1038/s41467-020-14793-0\n\n    Args:\n        data (np.ndarray): Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n\n    Returns:\n        xc (int): Coordinate of the diffraction center in x, such that the image center corresponds to data [yc, xc].\n        yc (int): Coordinate of the diffraction center in y, such that the image center corresponds to data [yc, xc].\n    \"\"\"\n\n    if mask is None:\n        mask = np.ones_like(data)\n    data = data * mask\n    indexes = np.where(data &gt; 0)\n    if np.sum(data[indexes]) &gt; 1e-7:\n        xc = np.sum(data[indexes] * indexes[1]) / np.sum(data[indexes])\n        yc = np.sum(data[indexes] * indexes[0]) / np.sum(data[indexes])\n    else:\n        xc = -1\n        yc = -1\n\n    if np.isnan(xc) or np.isnan(yc):\n        xc = -1\n        yc = -1\n\n    return [np.round(xc, 1), np.round(yc, 1)]\n</code></pre>"},{"location":"reference/utils/#bblib.utils.circle_mask","title":"<code>circle_mask(data, center, radius)</code>","text":"<p>Make a  ring mask for the data</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image in which mask will be shaped</p> required <code>radius</code> <code>int</code> <p>Outer radius of the mask</p> required <p>Returns:</p> Name Type Description <code>mask</code> <code>ndarray</code> <p>Mask array containg zeros (pixels to be masked) and ones (valid pixels).</p> Source code in <code>bblib/utils.py</code> <pre><code>def circle_mask(data: np.ndarray, center: tuple, radius: int) -&gt; np.ndarray:\n    \"\"\"\n    Make a  ring mask for the data\n\n    Args:\n        data (np.ndarray): Image in which mask will be shaped\n        radius (int): Outer radius of the mask\n\n    Returns:\n        mask (np.ndarray): Mask array containg zeros (pixels to be masked) and ones (valid pixels).\n    \"\"\"\n\n    bin_size = bin\n    a = data.shape[0]\n    b = data.shape[1]\n\n    [X, Y] = np.meshgrid(np.arange(b) - center[0], np.arange(a) - center[1])\n    R = np.sqrt(np.square(X) + np.square(Y))\n    return (np.greater(R, radius)).astype(np.int32)\n</code></pre>"},{"location":"reference/utils/#bblib.utils.correct_polarization","title":"<code>correct_polarization(x, y, dist, data, mask, polarization_axis='x', p=0.99)</code>","text":"<p>Correct data for polarisation effect, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234 Acknowledgements: Oleksandr Yefanov, Marina Galchenkova</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.</p> required <code>y</code> <code>ndarray</code> <p>Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.</p> required <code>dist</code> <code>float</code> <p>z distance coordinates of the detector position in pixels.</p> required <code>data</code> <code>ndarray</code> <p>Raw data frame in which polarization correction will be applied.</p> required <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> required <p>Returns:</p> Name Type Description <code>corrected_data</code> <code>ndarray</code> <p>Corrected data frame for polarization effect.</p> <code>pol</code> <code>ndarray</code> <p>Polarization array for polarization correction.</p> Source code in <code>bblib/utils.py</code> <pre><code>def correct_polarization(\n    x: np.ndarray,\n    y: np.ndarray,\n    dist: float,\n    data: np.ndarray,\n    mask: np.ndarray,\n    polarization_axis: str = \"x\",\n    p: float = 0.99,\n) -&gt; np.ndarray:\n    \"\"\"\n    Correct data for polarisation effect, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234\n    Acknowledgements: Oleksandr Yefanov, Marina Galchenkova\n\n    Args:\n        x (np.ndarray): Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.\n        y (np.ndarray): Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.\n        dist (float): z distance coordinates of the detector position in pixels.\n        data (np.ndarray): Raw data frame in which polarization correction will be applied.\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n\n    Returns:\n        corrected_data (np.ndarray): Corrected data frame for polarization effect.\n        pol (np.ndarray): Polarization array for polarization correction.\n    \"\"\"\n\n    mask = mask.astype(bool)\n    mask = mask.flatten()\n    intensity = np.reshape(data.copy(), len(mask))\n    pol = mask.copy().astype(np.float32)\n    pol = make_polarization_array(pol, x.flatten(), y.flatten(), dist, p)\n    intensity = intensity / pol\n    return intensity.reshape(data.shape), pol.reshape(data.shape)\n</code></pre>"},{"location":"reference/utils/#bblib.utils.fsss_to_xy","title":"<code>fsss_to_xy(point, m)</code>","text":"<p>Transforms from the fast-scan/slow-scan basis to the x/y basis.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>tuple</code> required <code>m</code> <code>list</code> <p>A 2x2 transformation matrix.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>The corresponding (x, y) coordinates.</p> Source code in <code>bblib/utils.py</code> <pre><code>def fsss_to_xy(point: tuple, m: list) -&gt; tuple:\n    \"\"\"\n    Transforms from the fast-scan/slow-scan basis to the x/y basis.\n\n    Args:\n        point (tuple):\n        m (list): A 2x2 transformation matrix.\n\n    Returns:\n        tuple: The corresponding (x, y) coordinates.\n\n    \"\"\"\n\n    d = m[0][0] * m[1][1] - m[0][1] * m[1][0]\n    ss = point[0] + 1\n    fs = point[1] + 1\n    x = int((m[1][1] / d) * fs - (m[0][1] / d) * ss)\n    y = int(-(m[1][0] / d) * fs + (m[0][0] / d) * ss)\n    return x, y\n</code></pre>"},{"location":"reference/utils/#bblib.utils.gaussian","title":"<code>gaussian(x, a, x0, sigma)</code>","text":"<p>Gaussian function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-axis.</p> required <code>a</code> <code>float</code> <p>Amplitude of the Gaussian.</p> required <code>x0</code> <code>float</code> <p>Average of the Gaussian.</p> required <code>sigma</code> <code>float</code> <p>Standard deviation of the Gaussian.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray</code> <p>y-axis.</p> Source code in <code>bblib/utils.py</code> <pre><code>def gaussian(x: np.ndarray, a: float, x0: float, sigma: float) -&gt; np.ndarray:\n    \"\"\"\n    Gaussian function.\n\n    Args:\n        x (np.ndarray): x-axis.\n        a (float): Amplitude of the Gaussian.\n        x0 (float): Average of the Gaussian.\n        sigma (float): Standard deviation of the Gaussian.\n\n    Returns:\n        y (np.ndarray): y-axis.\n    \"\"\"\n\n    return a * exp(-((x - x0) ** 2) / (2 * sigma**2))\n</code></pre>"},{"location":"reference/utils/#bblib.utils.gaussian_lin","title":"<code>gaussian_lin(x, a, x0, sigma, m, n)</code>","text":"<p>Gaussian function summed to a linear function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-axis.</p> required <code>a</code> <code>float</code> <p>Amplitude of the Gaussian.</p> required <code>x0</code> <code>float</code> <p>Average of the Gaussian.</p> required <code>sigma</code> <code>float</code> <p>Standard deviation of the Gaussian.</p> required <code>m</code> <code>float</code> <p>Angular coefficient.</p> required <code>n</code> <code>float</code> <p>Linear coefficient.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray</code> <p>y-axis.</p> Source code in <code>bblib/utils.py</code> <pre><code>def gaussian_lin(\n    x: np.ndarray, a: float, x0: float, sigma: float, m: float, n: float\n) -&gt; np.ndarray:\n    \"\"\"\n    Gaussian function summed to a linear function.\n\n    Args:\n        x (np.ndarray): x-axis.\n        a (float): Amplitude of the Gaussian.\n        x0 (float): Average of the Gaussian.\n        sigma (float): Standard deviation of the Gaussian.\n        m: Angular coefficient.\n        n: Linear coefficient.\n\n    Returns:\n        y (np.ndarray): y-axis.\n    \"\"\"\n    return m * x + n + a * exp(-((x - x0) ** 2) / (2 * sigma**2))\n</code></pre>"},{"location":"reference/utils/#bblib.utils.get_fwhm_map_global_min","title":"<code>get_fwhm_map_global_min(lines, output_folder, label, pixel_step, plots_flag)</code>","text":"<p>Open FWHM grid search optmization plot, fit projections in both axis to get the point of maximum sharpness of the radial average. TODO Refactor.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list</code> <p>Output of grid search for FWHM optmization, each line must contain a dictionary contaning entries for xc, yc and fwhm_over_radius.</p> required <code>output_folder</code> <code>str</code> <p>Path to the folder where plots are saved.</p> required <code>label</code> <code>str</code> <p>Plots filename label.</p> required <code>pixel_step</code> <code>str</code> <p>Step size between grid points in pixels.</p> required <code>plots_flag</code> <code>bool</code> <p>If True, plots can be generated.</p> required <p>Returns:</p> Name Type Description <code>xc</code> <code>int</code> <p>Coordinate of the diffraction center in x, such that the image center corresponds to data [yc, xc].</p> <code>yc</code> <code>int</code> <p>Coordinate of the diffraction center in y, such that the image center corresponds to data [yc, xc].</p> Source code in <code>bblib/utils.py</code> <pre><code>def get_fwhm_map_global_min(\n    lines: list, output_folder: str, label: str, pixel_step: int, plots_flag: bool\n) -&gt; tuple:\n    \"\"\"\n    Open FWHM grid search optmization plot, fit projections in both axis to get the point of maximum sharpness of the radial average.\n    TODO Refactor.\n\n    Args:\n        lines (list): Output of grid search for FWHM optmization, each line must contain a dictionary contaning entries for xc, yc and fwhm_over_radius.\n        output_folder (str): Path to the folder where plots are saved.\n        label (str): Plots filename label.\n        pixel_step (str): Step size between grid points in pixels.\n        plots_flag (bool): If True, plots can be generated.\n\n    Returns:\n        xc (int): Coordinate of the diffraction center in x, such that the image center corresponds to data [yc, xc].\n        yc (int): Coordinate of the diffraction center in y, such that the image center corresponds to data [yc, xc].\n    \"\"\"\n    n = int(math.sqrt(len(lines)))\n\n    merged_dict = {}\n    for dictionary in lines[:]:\n        for key, value in dictionary.items():\n            if key in merged_dict:\n                merged_dict[key].append(value)\n            else:\n                merged_dict[key] = [value]\n\n    # Create a figure with three subplots\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(10, 10))\n\n    # Extract x, y, and z from merged_dict\n\n    x = np.array(merged_dict[\"xc\"]).reshape((n, n))[0]\n    y = np.array(merged_dict[\"yc\"]).reshape((n, n))[:, 0]\n    z = np.array(merged_dict[\"fwhm\"], dtype=np.float64).reshape((n, n))\n    r = np.array(merged_dict[\"r_squared\"]).reshape((n, n))\n    z = np.nan_to_num(z)\n    r = np.nan_to_num(r)\n    pos1 = ax1.imshow(z, cmap=\"rainbow\")\n    step = 10\n    n = z.shape[0]\n\n    ax1.set_xticks(np.arange(0, n, step, dtype=int))\n    ax1.set_yticks(np.arange(0, n, step, dtype=int))\n\n    step = round(step * (abs(x[0] - x[1])), 1)\n    ax1.set_xticklabels(\n        np.arange(round(x[0], 1), round(x[-1] + step, 1), step, dtype=int), rotation=45\n    )\n    ax1.set_yticklabels(\n        np.arange(round(y[0], 1), round(y[-1] + step, 1), step, dtype=int)\n    )\n    ax1.set_ylabel(\"yc [px]\")\n    ax1.set_xlabel(\"xc [px]\")\n    ax1.set_title(\"FWHM\")\n\n    pos2 = ax2.imshow(r, cmap=\"rainbow\")\n    step = 10\n    n = z.shape[0]\n\n    ax2.set_xticks(np.arange(0, n, step, dtype=int))\n    ax2.set_yticks(np.arange(0, n, step, dtype=int))\n\n    step = round(step * (abs(x[0] - x[1])), 1)\n    ax2.set_xticklabels(\n        np.arange(round(x[0], 1), round(x[-1] + step, 1), step, dtype=int), rotation=45\n    )\n    ax2.set_yticklabels(\n        np.arange(round(y[0], 1), round(y[-1] + step, 1), step, dtype=int)\n    )\n\n    ax2.set_ylabel(\"yc [px]\")\n    ax2.set_xlabel(\"xc [px]\")\n    ax2.set_title(\"R\u00b2\")\n\n    proj_x = np.sum(z, axis=0) // n\n    x = np.arange(x[0], x[-1] + pixel_step, pixel_step)\n    index_x = np.unravel_index(np.argmin(proj_x, axis=None), proj_x.shape)\n    xc = x[index_x]\n    ax3.scatter(x, proj_x, color=\"b\")\n    ax3.scatter(xc, proj_x[index_x], color=\"r\", label=f\"xc: {xc}\")\n    ax3.set_ylabel(\"Average FWHM\")\n    ax3.set_xlabel(\"xc [px]\")\n    ax3.set_title(\"FWHM projection in x\")\n    ax3.legend()\n\n    proj_y = np.sum(z, axis=1) // n\n    x = np.arange(y[0], y[-1] + pixel_step, pixel_step)\n    index_y = np.unravel_index(np.argmin(proj_y, axis=None), proj_y.shape)\n    yc = x[index_y]\n    ax4.scatter(x, proj_y, color=\"b\")\n    ax4.scatter(yc, proj_y[index_y], color=\"r\", label=f\"yc: {yc}\")\n    ax4.set_ylabel(\"Average FWHM\")\n    ax4.set_xlabel(\"yc [px]\")\n    ax4.set_title(\"FWHM projection in y\")\n    ax4.legend()\n\n    fig.colorbar(pos1, ax=ax1, shrink=0.6)\n    fig.colorbar(pos2, ax=ax2, shrink=0.6)\n\n    if int(np.sum(proj_y)) == 0 or int(np.sum(proj_x)) == 0:\n        xc = -1\n        yc = -1\n    else:\n        if plots_flag:\n            plt.savefig(f\"{output_folder}/fwhm_map/{label}.png\")\n    plt.close()\n    return [np.round(xc, 0), np.round(yc, 0)]\n</code></pre>"},{"location":"reference/utils/#bblib.utils.make_polarization_array","title":"<code>make_polarization_array(pol, cox, coy, detdist, poldegree)</code>","text":"<p>Create the polarization array for horizontal polarization correction, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234 Acknowledgements: Oleksandr Yefanov, Marina Galchenkova</p> <p>Parameters:</p> Name Type Description Default <code>pol</code> <code>ndarray</code> <p>An array where polarization arra will be built based on its shape. Mask shape is the same size of data. Unvalid pixels (values containing 0) will be skipped from calculation and put 1.</p> required <code>cox</code> <code>ndarray</code> <p>Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.</p> required <code>coy</code> <code>ndarray</code> <p>Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.</p> required <code>detdist</code> <code>float</code> <p>Detector distance from the sample in meters . The detctor distance will be transformed in pixel units based on Res defined as global parameter.</p> required <code>poldegree</code> <code>float</code> <p>Polarization degree from [0,1]. The horizontal polarization at most synchrotrons sources, e.g DESY, p is 0.99.</p> required <p>Returns:     pol (np.ndarray): Polarization array for polarization correction.</p> Source code in <code>bblib/utils.py</code> <pre><code>def make_polarization_array(\n    pol: np.ndarray, cox: np.ndarray, coy: np.ndarray, detdist: float, poldegree: float\n) -&gt; np.ndarray:\n    \"\"\"\n    Create the polarization array for horizontal polarization correction, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234\n    Acknowledgements: Oleksandr Yefanov, Marina Galchenkova\n\n    Args:\n        pol (np.ndarray): An array where polarization arra will be built based on its shape. Mask shape is the same size of data. Unvalid pixels (values containing 0) will be skipped from calculation and put 1.\n        cox (np.ndarray): Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.\n        coy (np.ndarray): Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.\n        detdist (float): Detector distance from the sample in meters . The detctor distance will be transformed in pixel units based on Res defined as global parameter.\n        poldegree (float): Polarization degree from [0,1]. The horizontal polarization at most synchrotrons sources, e.g DESY, p is 0.99.\n    Returns:\n        pol (np.ndarray): Polarization array for polarization correction.\n    \"\"\"\n\n    z = detdist * np.ones(cox.shape[0])\n    valid = np.where(pol == 1)\n\n    pol[valid] = 1 - (\n        (poldegree * (cox[valid] ** 2) + (1 - poldegree) * (coy[valid] ** 2))\n        / (cox[valid] ** 2 + coy[valid] ** 2 + z[valid] ** 2)\n    )\n    pol[np.where(pol == 0)] = 1.0\n\n    return pol\n</code></pre>"},{"location":"reference/utils/#bblib.utils.mask_peaks","title":"<code>mask_peaks(mask, indexes, bragg, n)</code>","text":"<p>Gather coordinates of a box of 1x1 pixels around each point from the indexes list. Bragg flag indicates if the mask returned will contain only bragg peaks regions (bragg =1), no bragg peaks regions (bragg=0), or both (bragg =-1).</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>An array where mask will be built based on its shape. Mask shape is the same size of data.</p> required <code>indexes</code> <code>tuple</code> <p>Bragg peaks coordinates, indexes[0] contains x-coordinates of Bragg peaks and indexes[1] the corresponding y-coordinates.</p> required <code>bragg</code> <code>int</code> <p>Bragg flag, choose between return only peaks, only background or both (bypass masking of peaks).</p> required <code>n</code> <code>int</code> <p>Number of pixels to build a 2*n box around the Bragg peaks.</p> required <p>Returns:</p> Name Type Description <code>surrounding_mask</code> <code>ndarray</code> <p>Corresponding mask according to bragg flag choice. It contains zeros for unvalid pixels and one for valid pixels. Mask shape is the same size of data.</p> Source code in <code>bblib/utils.py</code> <pre><code>def mask_peaks(mask: np.ndarray, indexes: tuple, bragg: int, n: int) -&gt; np.ndarray:\n    \"\"\"\n    Gather coordinates of a box of 1x1 pixels around each point from the indexes list. Bragg flag indicates if the mask returned will contain only bragg peaks regions (bragg =1), no bragg peaks regions (bragg=0), or both (bragg =-1).\n\n    Args:\n        mask (np.ndarray): An array where mask will be built based on its shape. Mask shape is the same size of data.\n        indexes (tuple): Bragg peaks coordinates, indexes[0] contains x-coordinates of Bragg peaks and indexes[1] the corresponding y-coordinates.\n        bragg (int): Bragg flag, choose between return only peaks, only background or both (bypass masking of peaks).\n        n (int): Number of pixels to build a 2*n box around the Bragg peaks.\n\n    Returns:\n        surrounding_mask (np.ndarray): Corresponding mask according to bragg flag choice. It contains zeros for unvalid pixels and one for valid pixels. Mask shape is the same size of data.\n    \"\"\"\n    surrounding_positions = []\n    count = 0\n    for index in zip(indexes[0], indexes[1]):\n        row, col = index\n        for i in range(-n, n + 1):\n            for k in range(-n, n + 1):\n                surrounding_positions.append((row + i, col + k))\n        count += 1\n\n    # print(args.bragg)\n    if bragg == 1:\n        surrounding_mask = np.zeros_like(mask)\n        for pos in surrounding_positions:\n            row, col = pos\n            if 0 &lt;= row &lt; mask.shape[0] and 0 &lt;= col &lt; mask.shape[1]:\n                surrounding_mask[row, col] = 1\n    elif bragg == -1:\n        surrounding_mask = np.ones_like(mask)\n    else:\n        surrounding_mask = np.ones_like(mask)\n        for pos in surrounding_positions:\n            row, col = pos\n            if 0 &lt;= row &lt; mask.shape[0] and 0 &lt;= col &lt; mask.shape[1]:\n                surrounding_mask[row, col] = 0\n\n    return surrounding_mask\n</code></pre>"},{"location":"reference/utils/#bblib.utils.ring_mask","title":"<code>ring_mask(data, center, inner_radius, outer_radius)</code>","text":"<p>Make a  ring mask for the data</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image in which mask will be shaped</p> required <code>center</code> <code>tuple</code> <p>(xc,yc)</p> required <code>inner_radius</code> <code>int</code> required <code>outer_radius</code> <code>int</code> required <p>Returns:</p> Name Type Description <code>mask</code> <code>ndarray</code> <p>Mask array containg zeros (pixels to be masked) and ones (valid pixels).</p> Source code in <code>bblib/utils.py</code> <pre><code>def ring_mask(\n    data: np.ndarray, center: tuple, inner_radius: int, outer_radius: int\n) -&gt; np.ndarray:\n    \"\"\"\n    Make a  ring mask for the data\n\n    Args:\n        data (np.ndarray): Image in which mask will be shaped\n        center (tuple): (xc,yc)\n        inner_radius (int):\n        outer_radius (int):\n\n    Returns:\n        mask (np.ndarray): Mask array containg zeros (pixels to be masked) and ones (valid pixels).\n    \"\"\"\n\n    bin_size = bin\n    a = data.shape[0]\n    b = data.shape[1]\n    [X, Y] = np.meshgrid(np.arange(b) - center[0], np.arange(a) - center[1])\n    R = np.sqrt(np.square(X) + np.square(Y))\n    bin_size = outer_radius - inner_radius\n    return np.greater(R, outer_radius - bin_size) &amp; np.less(R, outer_radius + bin_size)\n</code></pre>"},{"location":"reference/utils/#bblib.utils.visualize_single_panel","title":"<code>visualize_single_panel(data, transformation_matrix, ss_in_rows)</code>","text":"<p>Creates a visulization array for single panel detectors after applying the detector geometry.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image in which mask will be shaped</p> required <code>transformation_matrix</code> <code>ndarray</code> <p>A 2x2 transformation matrix used to map         from fast-scan/slow-scan to x/y coordinates.     ss_in_rows (bool): If True, the slow-scan axis is mapped to rows; otherwise to columns.</p> <p>Returns:     np.ndarray: The transformed visualization array.</p> required Source code in <code>bblib/utils.py</code> <pre><code>def visualize_single_panel(\n    data: np.ndarray, transformation_matrix: np.ndarray, ss_in_rows: bool\n) -&gt; np.ndarray:\n    \"\"\"\n    Creates a visulization array for single panel detectors after applying the detector geometry.\n\n    Args:\n        data (np.ndarray): Image in which mask will be shaped\n        transformation_matrix (np.ndarray): A 2x2 transformation matrix used to map\n                    from fast-scan/slow-scan to x/y coordinates.\n                ss_in_rows (bool): If True, the slow-scan axis is mapped to rows; otherwise to columns.\n\n            Returns:\n                np.ndarray: The transformed visualization array.\n    \"\"\"\n    visual_data = np.full((2 * max(data.shape) + 1, 2 * max(data.shape) + 1), np.nan)\n\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            point = (i, j) if ss_in_rows else (j, i)\n            xy_j, xy_i = fsss_to_xy(point, transformation_matrix)\n            visual_data[xy_i][xy_j] = data[i][j]\n\n    non_nan_indices = np.where(~np.isnan(visual_data))\n    min_row_index, min_col_index = np.min(non_nan_indices, axis=1)\n    max_row_index, max_col_index = np.max(non_nan_indices, axis=1)\n\n    return visual_data[\n        min_row_index : max_row_index + 1, min_col_index : max_col_index + 1\n    ]\n</code></pre>"},{"location":"tutorial/center_of_mass/center_of_mass/","title":"Center of mass","text":"<pre><code>import h5py\nimport hdf5plugin\nimport numpy as np\nimport fabio\nimport matplotlib.pyplot as plt\nimport om.lib.geometry as geometry\n\nfrom bblib.methods import CenterOfMass\nfrom bblib.models import PF8Info, PF8\nfrom bblib.utils import visualize_single_panel\n</code></pre> <p>Set here the absolute path to bblib_tutorial</p> <pre><code>tutorial_path=\"/path/to/bblib_tutorial\"\n</code></pre> <p>You will need to set the tutorial_path on the mask_file parameter in the geometry files cointaned in the bblib_tutorial/geoms folder</p> <pre><code>config = {\n    \"plots_flag\": True,\n    \"pf8\": {\n        \"max_num_peaks\": 10000,\n        \"adc_threshold\": 10,\n        \"minimum_snr\": 5,\n        \"min_pixel_count\": 2,\n        \"max_pixel_count\": 200,\n        \"local_bg_radius\": 3,\n        \"min_res\": 0,\n        \"max_res\": 1200\n        },\n    \"offset\": {\n        \"x\": 0.5,\n        \"y\": 0.5\n        },\n    \"bragg_peaks_positions_for_center_of_mass_calculation\": 0,\n    \"pixels_for_mask_of_bragg_peaks\": 2,\n    \"polarization\": {\n        \"apply_polarization_correction\": True,\n        \"axis\":\"x\",\n        \"value\":0.99\n        }\n}\n</code></pre> <pre><code>PF8Config=PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"]\n    )\n</code></pre> <p>First, open your raw file:</p> <pre><code>cbf_file=f\"{tutorial_path}/data/chipD_001_00111.cbf\"\ndata = fabio.open(cbf_file).data\n</code></pre> <p>Indicate the geometry filename that describes the initial detector geometry according to CrystFEL:</p> <pre><code>geometry_filename=f\"{tutorial_path}/geoms/pilatus6M.geom\"\n</code></pre> <p>If you want to check and have a look how the data looks like:</p> <pre><code>hdf5_file=f\"{tutorial_path}/masks/mask_chipD_001_00111.h5\"\nf = h5py.File(hdf5_file, \"r\")\nmask = np.array(f[\"data/data\"])\nf.close()\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(data*mask, vmin=0,vmax=10)\nplt.show()\n</code></pre>          Figure"},{"location":"tutorial/center_of_mass/center_of_mass/#set-detector-geometry","title":"Set detector geometry","text":"<pre><code>PF8Config.set_geometry_from_file(geometry_filename)\n</code></pre> <p>Visualize multi panels detector</p> <pre><code># Not the case here, so I am commenting this\n#data_visualize = geometry.DataVisualizer(pixel_maps=PF8Config.pixel_maps)\n#visual_data = data_visualize.visualize_data(data=data * mask)\n#plt.close()\n#%matplotlib widget\n#plt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <p>Visualize single panel detector</p> <pre><code>visual_data = visualize_single_panel(data*mask, PF8Config.transformation_matrix, PF8Config.ss_in_rows)\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <pre><code>&lt;matplotlib.image.AxesImage at 0x2aae63d0b100&gt;\n</code></pre>          Figure"},{"location":"tutorial/center_of_mass/center_of_mass/#run-the-centering","title":"Run the centering","text":"<p>Dictionaries config and PF8Config ready for centering:</p> <p>If you want to save intermediate steps plots, set the path as root_path/run_label/*/file_label_frame_index.png</p> <pre><code>plots_info={\n    \"file_name\": \"chip_D_111\",\n    \"folder_name\": \"fakp\",\n    \"root_path\": f\"{tutorial_path}\",\n    \"value_auto\": True,\n    \"axis_lim_auto\": True,\n    \"color_map\": \"viridis\"\n}\n</code></pre> <pre><code>center_of_mass_method = CenterOfMass(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\n</code></pre> <pre><code>center_coordinates_from_center_of_mass = center_of_mass_method(\n                        data = data\n                    )\n</code></pre> <p>Print the final result:</p> <pre><code>center_coordinates_from_center_of_mass\n</code></pre> <pre><code>array([1250., 1338.])\n</code></pre> <pre><code>PF8Config.detector_center_from_geom\n</code></pre> <pre><code>[1252, 1349]\n</code></pre> <pre><code>beam_position_shift = [center_coordinates_from_center_of_mass[x] - PF8Config.detector_center_from_geom[x] for x in range(2)]\n</code></pre> <pre><code>detector_shift_in_mm = [np.round(-1 * x *1e3 / PF8Config.pixel_resolution, 4) for x in beam_position_shift]\n</code></pre> <pre><code>detector_shift_in_mm\n</code></pre> <pre><code>[0.344, 1.892]\n</code></pre>"},{"location":"tutorial/circle_detection/circle_detection/","title":"Circle detection","text":"<pre><code>import h5py\nimport hdf5plugin\nimport numpy as np\nimport fabio\nimport matplotlib.pyplot as plt\nimport om.lib.geometry as geometry\n\nfrom bblib.methods import CircleDetection\nfrom bblib.models import PF8Info, PF8\nfrom bblib.utils import visualize_single_panel\n</code></pre> <p>Set here the absolute path to bblib_tutorial</p> <pre><code>tutorial_path=\"/path/to/bblib_tutorial\"\n</code></pre> <p>You will need to set the tutorial_path on the mask_file parameter in the geometry files cointaned in the bblib_tutorial/geoms folder</p> <pre><code>config = {\n    \"plots_flag\": True,\n    \"pf8\": {\n        \"max_num_peaks\": 10000,\n        \"adc_threshold\": 10,\n        \"minimum_snr\": 5,\n        \"min_pixel_count\": 2,\n        \"max_pixel_count\": 200,\n        \"local_bg_radius\": 3,\n        \"min_res\": 0,\n        \"max_res\": 1200\n        },\n    \"offset\": {\n        \"x\": 0.5,\n        \"y\": 0.5\n        },\n    \"peak_region\":{\n        \"min\": 60,\n        \"max\": 80\n        },\n    \"canny\":{\n        \"sigma\": 3,\n        \"low_threshold\": 0.9,\n        \"high_threshold\": 0.99\n        },\n    \"bragg_peaks_positions_for_center_of_mass_calculation\": 0,\n    \"pixels_for_mask_of_bragg_peaks\": 2,\n    \"polarization\": {\n        \"apply_polarization_correction\":True,\n        \"axis\":\"x\",\n        \"value\":0.99\n        }\n}\n</code></pre> <pre><code>PF8Config=PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"]\n    )\n</code></pre> <p>First, open your raw file:</p> <pre><code>hdf5_file=f\"{tutorial_path}/data/lyso_test_data_000014.h5\"\nf = h5py.File(hdf5_file, \"r\")\ndata = np.array(f[\"entry/data/data\"][2], dtype=np.int32)\nf.close()\n</code></pre> <p>Indicate the geometry filename that describes the initial detector geometry according to CrystFEL:</p> <pre><code>geometry_filename=f\"{tutorial_path}/geoms/eiger500k.geom\"\n</code></pre> <p>If you want to check and have a look how the data looks like:</p> <pre><code>hdf5_file=f\"{tutorial_path}/masks/mask_lyso_test_data_000014.h5\"\nf = h5py.File(hdf5_file, \"r\")\nmask = np.array(f[\"data/data\"])\nf.close()\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(data*mask, vmin=0,vmax=10)\nplt.show()\n</code></pre>          Figure"},{"location":"tutorial/circle_detection/circle_detection/#set-detector-geometry","title":"Set detector geometry","text":"<pre><code>PF8Config.set_geometry_from_file(geometry_filename)\n</code></pre> <p>Visualize multi panels detector</p> <pre><code># Not the case here, so I am commenting this\n#data_visualize = geometry.DataVisualizer(pixel_maps=PF8Config.pixel_maps)\n#visual_data = data_visualize.visualize_data(data=data * mask)\n#plt.close()\n#%matplotlib widget\n#plt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <p>Visualize single panel detector</p> <pre><code>visual_data = visualize_single_panel(data*mask, PF8Config.transformation_matrix, PF8Config.ss_in_rows)\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <pre><code>&lt;matplotlib.image.AxesImage at 0x2ad4a70695d0&gt;\n</code></pre>          Figure"},{"location":"tutorial/circle_detection/circle_detection/#run-the-centering","title":"Run the centering","text":"<p>Dictionaries config and PF8Config ready for centering:</p> <p>If you want to save intermediate steps plots, set the path as root_path/run_label/*/file_label_frame_index.png</p> <pre><code>plots_info={\n    \"file_name\": \"lyso_2\",\n    \"folder_name\": \"beam_sweeping_lyso\",\n    \"root_path\": f\"{tutorial_path}\",\n    \"value_auto\": True,\n    \"axis_lim_auto\": True,\n    \"color_map\": \"viridis\"\n}\n</code></pre> <pre><code>circle_detection_method = CircleDetection(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\n</code></pre> <pre><code>center_coordinates_from_circle_detection = circle_detection_method(\n                        data = data\n                    )\n</code></pre> <p>Print the final result:</p> <pre><code>center_coordinates_from_circle_detection\n</code></pre> <pre><code>[401.5, 438.5]\n</code></pre> <pre><code>PF8Config.detector_center_from_geom\n</code></pre> <pre><code>[401, 370]\n</code></pre> <pre><code>beam_position_shift = [center_coordinates_from_circle_detection[x] - PF8Config.detector_center_from_geom[x] for x in range(2)]\n</code></pre> <pre><code>detector_shift_in_mm = [np.round(-1 * x *1e3 / PF8Config.pixel_resolution, 4) for x in beam_position_shift]\n</code></pre> <pre><code>detector_shift_in_mm\n</code></pre> <pre><code>[-0.0375, -5.1375]\n</code></pre>"},{"location":"tutorial/friedel_pairs/friedel_pairs/","title":"Friedel pairs","text":"<pre><code>import h5py\nimport hdf5plugin\nimport numpy as np\nimport fabio\nimport matplotlib.pyplot as plt\nimport om.lib.geometry as geometry\n\nfrom bblib.methods import FriedelPairs\nfrom bblib.models import PF8Info, PF8\nfrom bblib.utils import visualize_single_panel\n</code></pre> <p>Set here the absolute path to bblib_tutorial</p> <pre><code>tutorial_path=\"/path/to/bblib_tutorial\"\n</code></pre> <p>You will need to set the tutorial_path on the mask_file parameter in the geometry files cointaned in the bblib_tutorial/geoms folder</p> <pre><code>config = {\n    \"plots_flag\": True,\n    \"search_radius\": 4,\n    \"pf8\": {\n        \"max_num_peaks\": 10000,\n        \"adc_threshold\": 10,\n        \"minimum_snr\": 5,\n        \"min_pixel_count\": 2,\n        \"max_pixel_count\": 200,\n        \"local_bg_radius\": 3,\n        \"min_res\": 0,\n        \"max_res\": 1200\n        },\n    \"offset\": {\n        \"x\": 0.5,\n        \"y\": 0.5\n        },\n    \"polarization\": {\n        \"apply_polarization_correction\": True,\n        \"axis\":\"x\",\n        \"value\":0.99\n        }\n}\n</code></pre> <pre><code>PF8Config=PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"]\n    )\n</code></pre> <p>First, open your raw file:</p> <pre><code>hdf5_file=f\"{tutorial_path}/data/lyso_test_data_000014.h5\"\nf = h5py.File(hdf5_file, \"r\")\ndata = np.array(f[\"entry/data/data\"][2], dtype=np.int32)\nf.close()\n</code></pre> <p>Indicate the geometry filename that describes the initial detector geometry according to CrystFEL:</p> <pre><code>geometry_filename=f\"{tutorial_path}/geoms/eiger500k.geom\"\n</code></pre> <p>If you want to check and have a look how the data looks like:</p> <pre><code>hdf5_file=f\"{tutorial_path}/masks/mask_lyso_test_data_000014.h5\"\nf = h5py.File(hdf5_file, \"r\")\nmask = np.array(f[\"data/data\"])\nf.close()\n</code></pre> <pre><code>%matplotlib widget\nplt.imshow(data*mask, vmin=0,vmax=10)\nplt.show()\n</code></pre>          Figure"},{"location":"tutorial/friedel_pairs/friedel_pairs/#set-detector-geometry","title":"Set detector geometry","text":"<pre><code>PF8Config.set_geometry_from_file(geometry_filename)\n</code></pre> <p>Visualize multi panels detector</p> <pre><code># Not the case here, so I am commenting this\n#data_visualize = geometry.DataVisualizer(pixel_maps=PF8Config.pixel_maps)\n#visual_data = data_visualize.visualize_data(data=data * mask)\n#plt.close()\n#%matplotlib widget\n#plt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <p>Visualize single panel detector</p> <pre><code>visual_data = visualize_single_panel(data*mask, PF8Config.transformation_matrix, PF8Config.ss_in_rows)\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <pre><code>&lt;matplotlib.image.AxesImage at 0x2b8655675600&gt;\n</code></pre>          Figure"},{"location":"tutorial/friedel_pairs/friedel_pairs/#run-the-centering","title":"Run the centering","text":"<p>Dictionaries config and PF8Config ready for centering:</p> <p>For the FriedelPairs method an initial_guess need to be passed, set here the coordinates in x and y of the initial guess for the center after setting the detector geometry:</p> <pre><code>initial_guess=[402,440]\n</code></pre> <p>If you want to save intermediate steps plots, set the path as root_path/run_label/*/file_label_frame_index.png</p> <pre><code>plots_info={\n    \"file_name\": \"lyso_2\",\n    \"folder_name\": \"beam_sweeping_lyso\",\n    \"root_path\": f\"{tutorial_path}\",\n    \"value_auto\": True,\n    \"axis_lim_auto\": True,\n    \"color_map\": \"viridis\"\n}\n</code></pre> <pre><code>friedel_pairs_method = FriedelPairs(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\n</code></pre> <pre><code>center_coordinates_from_friedel_pairs = friedel_pairs_method(\n                        data = data, initial_guess= initial_guess\n                    )\n</code></pre> <pre><code>--------------  Friedel pairs search --------------\nNumber of Friedel Pairs in frame: 1.0\nPairs list for analysis:\n[((-73.5, 188.5), (-74.5, 190.5)), ((74.5, -190.5), (73.5, -188.5))]\nFriedel pairs position before center correction in pixels:\n[(-73.5, 188.5), (74.5, -190.5)]\nCenter shift in x 0.5\nCenter shift in y -1.0\nFriedel pairs position after center correction in pixels:\n[(-74.0, 189.5), (74.0, -189.5)]\nAll reflections after center correction in pixels:\n[(-391.0, -146.5), (-358.0, 31.5), (-357.0, 7.5), (-355.0, -16.5), (-354.0, -40.5), (-352.0, 85.5), (-350.0, -202.5), (-336.0, 144.5), (-332.0, 158.5), (-330.0, -125.5), (-308.0, -283.5), (-287.0, -200.5), (-284.0, 20.5), (-281.0, 58.5), (-281.0, -26.5), (-277.0, -219.5), (-274.0, -59.5), (-269.0, -68.5), (-258.0, 145.5), (-258.0, -110.5), (-242.0, -137.5), (-241.0, 179.5), (-231.0, -156.5), (-221.0, -274.5), (-216.0, -21.5), (-206.0, 224.5), (-199.0, 39.5), (-196.0, -116.5), (-196.0, -196.5), (-186.0, 49.5), (-186.0, -34.5), (-184.0, 85.5), (-174.0, 255.5), (-171.0, -219.5), (-167.0, 119.5), (-165.0, 260.5), (-161.0, 217.5), (-154.0, 139.5), (-153.0, 99.5), (-152.0, -232.5), (-149.0, -67.5), (-142.0, 158.5), (-135.0, -125.5), (-131.0, 301.5), (-130.0, -133.5), (-129.0, -143.5), (-126.0, -332.5), (-120.0, 182.5), (-120.0, 126.5), (-111.0, 188.5), (-104.0, 109.5), (-102.0, 193.5), (-88.0, -24.5), (-87.0, -168.5), (-79.0, -211.5), (-74.0, 208.5), (-74.0, 189.5), (-73.0, 313.5), (-72.0, -172.5), (-65.0, 214.5), (-57.0, 219.5), (10.0, 360.5), (17.0, 328.5), (68.0, -189.5), (74.0, -189.5), (92.0, 176.5), (97.0, -45.5), (97.0, -108.5), (98.0, 223.5), (100.0, -183.5), (106.0, 125.5), (107.0, -87.5), (107.0, -422.5)]\n-- End --\n</code></pre> <p>Print the final result:</p> <pre><code>center_coordinates_from_friedel_pairs\n</code></pre> <pre><code>[403.0, 439.5]\n</code></pre> <pre><code>PF8Config.detector_center_from_geom\n</code></pre> <pre><code>[401, 370]\n</code></pre> <pre><code>beam_position_shift = [center_coordinates_from_friedel_pairs[x] - PF8Config.detector_center_from_geom[x] for x in range(2)]\n</code></pre> <pre><code>beam_position_shift\n</code></pre> <pre><code>[2.0, 69.5]\n</code></pre> <pre><code>detector_shift_in_mm = [np.round(-1 * x *1e3 / PF8Config.pixel_resolution, 4) for x in beam_position_shift]\n</code></pre> <pre><code>detector_shift_in_mm\n</code></pre> <pre><code>[-0.15, -5.2125]\n</code></pre>"},{"location":"tutorial/minimize_peak_fwhm/minimize_peak_fwhm/","title":"Minimize peak FWHM","text":"<pre><code>import h5py\nimport hdf5plugin\nimport numpy as np\nimport fabio\nimport matplotlib.pyplot as plt\nimport om.lib.geometry as geometry\n\nfrom bblib.methods import MinimizePeakFWHM\nfrom bblib.models import PF8Info, PF8\nfrom bblib.utils import visualize_single_panel\n</code></pre> <p>Set here the absolute path to bblib_tutorial</p> <pre><code>tutorial_path=\"/path/to/bblib_tutorial\"\n</code></pre> <p>You will need to set the tutorial_path on the mask_file parameter in the geometry files cointaned in the bblib_tutorial/geoms folder</p> <pre><code>config = {\n    \"plots_flag\": True,\n    \"pf8\": {\n        \"max_num_peaks\": 10000,\n        \"adc_threshold\": 10,\n        \"minimum_snr\": 5,\n        \"min_pixel_count\": 2,\n        \"max_pixel_count\": 200,\n        \"local_bg_radius\": 3,\n        \"min_res\": 0,\n        \"max_res\": 1200\n        },\n    \"offset\": {\n        \"x\": 0.5,\n        \"y\": 0.5\n        },\n    \"peak_region\":{\n        \"min\": 200,\n        \"max\": 400\n        },\n    \"bragg_peaks_positions_for_center_of_mass_calculation\": 0,\n    \"pixels_for_mask_of_bragg_peaks\": 2,\n    \"polarization\": {\n        \"apply_polarization_correction\":True,\n        \"axis\":\"x\",\n        \"value\":0.99\n        }\n}\n</code></pre> <pre><code>PF8Config=PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"]\n    )\n</code></pre> <p>First, open your raw file:</p> <pre><code>cbf_file=f\"{tutorial_path}/data/chipD_001_00111.cbf\"\ndata = fabio.open(cbf_file).data\n</code></pre> <p>Indicate the geometry filename that describes the initial detector geometry according to CrystFEL:</p> <pre><code>geometry_filename=f\"{tutorial_path}/geoms/pilatus6M.geom\"\n</code></pre> <p>If you want to check and have a look how the data looks like:</p> <pre><code>hdf5_file=f\"{tutorial_path}/masks/mask_chipD_001_00111.h5\"\nf = h5py.File(hdf5_file, \"r\")\nmask = np.array(f[\"data/data\"])\nf.close()\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(data*mask, vmin=0,vmax=10)\nplt.show()\n</code></pre>          Figure"},{"location":"tutorial/minimize_peak_fwhm/minimize_peak_fwhm/#set-detector-geometry","title":"Set detector geometry","text":"<pre><code>PF8Config.set_geometry_from_file(geometry_filename)\n</code></pre> <p>Visualize multi panels detector</p> <pre><code># Not the case here, so I am commenting this\n#data_visualize = geometry.DataVisualizer(pixel_maps=PF8Config.pixel_maps)\n#visual_data = data_visualize.visualize_data(data=data * mask)\n#plt.close()\n#%matplotlib widget\n#plt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <p>Visualize single panel detector</p> <pre><code>visual_data = visualize_single_panel(data*mask, PF8Config.transformation_matrix, PF8Config.ss_in_rows)\n</code></pre> <pre><code>plt.close()\n%matplotlib widget\nplt.imshow(visual_data, vmin=0, vmax=10, origin=\"lower\")\n</code></pre> <pre><code>&lt;matplotlib.image.AxesImage at 0x2ab4d9fd07c0&gt;\n</code></pre>          Figure"},{"location":"tutorial/minimize_peak_fwhm/minimize_peak_fwhm/#run-the-centering","title":"Run the centering","text":"<p>Dictionaries config and PF8Config ready for centering:</p> <p>For the MinimizePeakFWHM method an initial_guess need to be passed, set here the coordinates in x and y of the initial guess for the center after setting the detector geometry:</p> <pre><code>initial_guess=[1255,1355]\n</code></pre> <p>If you want to save intermediate steps plots, set the path as root_path/run_label/*/file_label_frame_index.png</p> <pre><code>plots_info={\n    \"file_name\": \"chip_D_111\",\n    \"folder_name\": \"fakp\",\n    \"root_path\": f\"{tutorial_path}\",\n    \"value_auto\": True,\n    \"axis_lim_auto\": True,\n    \"color_map\": \"viridis\"\n}\n</code></pre> <pre><code>minimize_peak_fwhm_method = MinimizePeakFWHM(\n                        config=config, PF8Config=PF8Config, plots_info=plots_info\n                    )\n</code></pre> <p>Warning</p> <p>Method not optmized, computationally yet, this might take a while. In the future, it might have a better version for this method</p> <pre><code>center_coordinates_from_minimize_peak_fwhm = minimize_peak_fwhm_method(\n                        data = data, initial_guess=initial_guess\n                    )\n</code></pre> <p>Print the final result:</p> <pre><code>center_coordinates_from_minimize_peak_fwhm\n</code></pre> <pre><code>[1249.5, 1372.5]\n</code></pre> <pre><code>PF8Config.detector_center_from_geom\n</code></pre> <pre><code>[1252, 1349]\n</code></pre> <pre><code>beam_position_shift = [center_coordinates_from_minimize_peak_fwhm[x] - PF8Config.detector_center_from_geom[x] for x in range(2)]\n</code></pre> <pre><code>detector_shift_in_mm = [np.round(-1 * x *1e3 / PF8Config.pixel_resolution, 4) for x in beam_position_shift]\n</code></pre> <pre><code>detector_shift_in_mm\n</code></pre> <pre><code>[0.43, -4.042]\n</code></pre>"}]}