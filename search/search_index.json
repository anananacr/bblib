{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to the beambusters library documentation!"},{"location":"reference/","title":"About bblib","text":"<p>The beambusters library (bblib) is a library that contains methods to determine the detector center directly from still diffraction patterns collected in serial crystallography experiments.</p> <p> Python 3.10</p>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#bblib.utils","title":"<code>utils</code>","text":""},{"location":"reference/utils/#bblib.utils.azimuthal_average","title":"<code>azimuthal_average(data, center=None, mask=None)</code>","text":"<p>Calculate azimuthal integration of data in relation to the center of the image Adapted from L. P. Ren\u00e9 de Cotret work on scikit-ued (https://github.com/LaurentRDC/scikit-ued/tree/master) L. P. Ren\u00e9 de Cotret, M. R. Otto, M. J. Stern. and B. J. Siwick, An open-source software ecosystem for the interactive exploration of ultrafast electron scattering data, Advanced Structural and Chemical Imaging 4:11 (2018) DOI: 10.1186/s40679-018-0060-y.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>ndarray</code> <p>Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.</p> <code>center</code> <code>tuple</code> <p>Center coordinates of the radial average (xc, yc)-&gt;(col, row).</p> <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> <p>Returns:</p> Name Type Description <code>radius</code> <code>ndarray</code> <p>Radial axis in pixels.</p> <code>intensity</code> <code>ndarray</code> <p>Integrated intensity normalized by the number of valid pixels.</p> Source code in <code>bblib/utils.py</code> <pre><code>def azimuthal_average(\n    data: np.ndarray, center: tuple = None, mask: np.ndarray = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculate azimuthal integration of data in relation to the center of the image\n    Adapted from L. P. Ren\u00e9 de Cotret work on scikit-ued (https://github.com/LaurentRDC/scikit-ued/tree/master)\n    L. P. Ren\u00e9 de Cotret, M. R. Otto, M. J. Stern. and B. J. Siwick, An open-source software ecosystem for the interactive exploration of ultrafast electron scattering data, Advanced Structural and Chemical Imaging 4:11 (2018) DOI: 10.1186/s40679-018-0060-y.\n\n    Attributes:\n        data (np.ndarray): Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.\n        center (tuple): Center coordinates of the radial average (xc, yc)-&gt;(col, row).\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n\n    Returns:\n        radius (np.ndarray): Radial axis in pixels.\n        intensity (np.ndarray): Integrated intensity normalized by the number of valid pixels.\n    \"\"\"\n    a = data.shape[0]\n    b = data.shape[1]\n    if mask is None:\n        mask = np.zeros((a, b), dtype=bool)\n    else:\n        mask.astype(bool)\n\n    if center is None:\n        center = [b / 2, a / 2]\n    [X, Y] = np.meshgrid(np.arange(b) - center[0], np.arange(a) - center[1])\n    R = np.sqrt(np.square(X) + np.square(Y))\n    Rint = np.rint(R).astype(int)\n\n    valid = mask.flatten()\n    data = data.flatten()\n    Rint = Rint.flatten()\n\n    px_bin = np.bincount(Rint, weights=valid * data)\n    r_bin = np.bincount(Rint, weights=valid)\n    radius = np.arange(0, r_bin.size)\n    # Replace by one if r_bin is zero for division\n    np.maximum(r_bin, 1, out=r_bin)\n\n    return radius, px_bin / r_bin\n</code></pre>"},{"location":"reference/utils/#bblib.utils.center_of_mass","title":"<code>center_of_mass(data, mask=None)</code>","text":"<p>Adapted from Robert B\u00fccker work on diffractem (https://github.com/robertbuecker/diffractem/tree/master) B\u00fccker, R., Hogan-Lamarre, P., Mehrabi, P. et al. Serial protein crystallography in an electron microscope. Nat Commun 11, 996 (2020). https://doi.org/10.1038/s41467-020-14793-0</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>ndarray</code> <p>Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.</p> <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> <p>Returns:</p> Name Type Description <code>xc</code> <code>int</code> <p>Coordinate of the diffraction center in x, such that the image center corresponds to data [yc, xc].</p> <code>yc</code> <code>int</code> <p>Coordinate of the diffraction center in y, such that the image center corresponds to data [yc, xc].</p> Source code in <code>bblib/utils.py</code> <pre><code>def center_of_mass(data: np.ndarray, mask: np.ndarray = None) -&gt; list[int]:\n    \"\"\"\n    Adapted from Robert B\u00fccker work on diffractem (https://github.com/robertbuecker/diffractem/tree/master)\n    B\u00fccker, R., Hogan-Lamarre, P., Mehrabi, P. et al. Serial protein crystallography in an electron microscope. Nat Commun 11, 996 (2020). https://doi.org/10.1038/s41467-020-14793-0\n\n    Attributes:\n        data (np.ndarray): Input data in which center of mass will be calculated. Values equal or less than zero will not be considered.\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n\n    Returns:\n        xc (int): Coordinate of the diffraction center in x, such that the image center corresponds to data [yc, xc].\n        yc (int): Coordinate of the diffraction center in y, such that the image center corresponds to data [yc, xc].\n    \"\"\"\n\n    if mask is None:\n        mask = np.ones_like(data)\n    data = data * mask\n    indexes = np.where(data &gt; 0)\n    if np.sum(data[indexes]) &gt; 1e-7:\n        xc = np.sum(data[indexes] * indexes[1]) / np.sum(data[indexes])\n        yc = np.sum(data[indexes] * indexes[0]) / np.sum(data[indexes])\n    else:\n        xc = -1\n        yc = -1\n\n    if np.isnan(xc) or np.isnan(yc):\n        xc = -1\n        yc = -1\n\n    return [np.round(xc, 1), np.round(yc, 1)]\n</code></pre>"},{"location":"reference/utils/#bblib.utils.circle_mask","title":"<code>circle_mask(data, center, radius)</code>","text":"<p>Make a  ring mask for the data</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>ndarray</code> <p>Image in which mask will be shaped</p> <code>radius</code> <code>int</code> <p>Outer radius of the mask</p> <p>Returns:</p> Name Type Description <code>mask</code> <code>ndarray</code> <p>Mask array containg zeros (pixels to be masked) and ones (valid pixels).</p> Source code in <code>bblib/utils.py</code> <pre><code>def circle_mask(data: np.ndarray, center: tuple, radius: int) -&gt; np.ndarray:\n    \"\"\"\n    Make a  ring mask for the data\n\n    Attributes:\n        data (np.ndarray): Image in which mask will be shaped\n        radius (int): Outer radius of the mask\n\n    Returns:\n        mask (np.ndarray): Mask array containg zeros (pixels to be masked) and ones (valid pixels).\n    \"\"\"\n\n    bin_size = bin\n    a = data.shape[0]\n    b = data.shape[1]\n\n    [X, Y] = np.meshgrid(np.arange(b) - center[0], np.arange(a) - center[1])\n    R = np.sqrt(np.square(X) + np.square(Y))\n    return (np.greater(R, radius)).astype(np.int32)\n</code></pre>"},{"location":"reference/utils/#bblib.utils.correct_polarization","title":"<code>correct_polarization(x, y, dist, data, mask, polarization_axis='x', p=0.99)</code>","text":"<p>Correct data for polarisation effect, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234 Acknowledgements: Oleksandr Yefanov, Marina Galchenkova</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.</p> <code>y</code> <code>ndarray</code> <p>Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.</p> <code>dist</code> <code>float</code> <p>z distance coordinates of the detector position in pixels.</p> <code>data</code> <code>ndarray</code> <p>Raw data frame in which polarization correction will be applied.</p> <code>mask</code> <code>ndarray</code> <p>Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.</p> <p>Returns:</p> Name Type Description <code>corrected_data</code> <code>ndarray</code> <p>Corrected data frame for polarization effect.</p> <code>pol</code> <code>ndarray</code> <p>Polarization array for polarization correction.</p> Source code in <code>bblib/utils.py</code> <pre><code>def correct_polarization(\n    x: np.ndarray,\n    y: np.ndarray,\n    dist: float,\n    data: np.ndarray,\n    mask: np.ndarray,\n    polarization_axis: str = \"x\",\n    p: float = 0.99,\n) -&gt; np.ndarray:\n    \"\"\"\n    Correct data for polarisation effect, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234\n    Acknowledgements: Oleksandr Yefanov, Marina Galchenkova\n\n    Attributes:\n        x (np.ndarray): Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.\n        y (np.ndarray): Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.\n        dist (float): z distance coordinates of the detector position in pixels.\n        data (np.ndarray): Raw data frame in which polarization correction will be applied.\n        mask (np.ndarray): Corresponding mask of data, containing zeros for unvalid pixels and one for valid pixels. Mask shape should be same size of data.\n\n    Returns:\n        corrected_data (np.ndarray): Corrected data frame for polarization effect.\n        pol (np.ndarray): Polarization array for polarization correction.\n    \"\"\"\n\n    mask = mask.astype(bool)\n    mask = mask.flatten()\n    intensity = np.reshape(data.copy(), len(mask))\n    pol = mask.copy().astype(np.float32)\n    pol = make_polarization_array(pol, x.flatten(), y.flatten(), dist, p)\n    intensity = intensity / pol\n    return intensity.reshape(data.shape), pol.reshape(data.shape)\n</code></pre>"},{"location":"reference/utils/#bblib.utils.gaussian","title":"<code>gaussian(x, a, x0, sigma)</code>","text":"<p>Gaussian function.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>x-axis.</p> <code>a</code> <code>float</code> <p>Amplitude of the Gaussian.</p> <code>x0</code> <code>float</code> <p>Average of the Gaussian.</p> <code>sigma</code> <code>float</code> <p>Standard deviation of the Gaussian.</p> <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray</code> <p>y-axis.</p> Source code in <code>bblib/utils.py</code> <pre><code>def gaussian(x: np.ndarray, a: float, x0: float, sigma: float) -&gt; np.ndarray:\n    \"\"\"\n    Gaussian function.\n\n    Attributes:\n        x (np.ndarray): x-axis.\n        a (float): Amplitude of the Gaussian.\n        x0 (float): Average of the Gaussian.\n        sigma (float): Standard deviation of the Gaussian.\n\n    Returns:\n        y (np.ndarray): y-axis.\n    \"\"\"\n\n    return a * exp(-((x - x0) ** 2) / (2 * sigma**2))\n</code></pre>"},{"location":"reference/utils/#bblib.utils.gaussian_lin","title":"<code>gaussian_lin(x, a, x0, sigma, m, n)</code>","text":"<p>Gaussian function summed to a linear function.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>x-axis.</p> <code>a</code> <code>float</code> <p>Amplitude of the Gaussian.</p> <code>x0</code> <code>float</code> <p>Average of the Gaussian.</p> <code>sigma</code> <code>float</code> <p>Standard deviation of the Gaussian.</p> <code>m</code> <code>float</code> <p>Angular coefficient.</p> <code>n</code> <code>float</code> <p>Linear coefficient.</p> <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray</code> <p>y-axis.</p> Source code in <code>bblib/utils.py</code> <pre><code>def gaussian_lin(\n    x: np.ndarray, a: float, x0: float, sigma: float, m: float, n: float\n) -&gt; np.ndarray:\n    \"\"\"\n    Gaussian function summed to a linear function.\n\n    Attributes:\n        x (np.ndarray): x-axis.\n        a (float): Amplitude of the Gaussian.\n        x0 (float): Average of the Gaussian.\n        sigma (float): Standard deviation of the Gaussian.\n        m: Angular coefficient.\n        n: Linear coefficient.\n\n    Returns:\n        y (np.ndarray): y-axis.\n    \"\"\"\n    return m * x + n + a * exp(-((x - x0) ** 2) / (2 * sigma**2))\n</code></pre>"},{"location":"reference/utils/#bblib.utils.get_fwhm_map_global_min","title":"<code>get_fwhm_map_global_min(lines, output_folder, label, pixel_step, plots_flag)</code>","text":"<p>Open FWHM grid search optmization plot, fit projections in both axis to get the point of maximum sharpness of the radial average.</p>"},{"location":"reference/utils/#bblib.utils.get_fwhm_map_global_min--to-rewrite","title":"To rewrite.","text":"<p>Attributes:</p> Name Type Description <code>lines</code> <code>list</code> <p>Output of grid search for FWHM optmization, each line should contain a dictionary contaning entries for xc, yc and fwhm_over_radius.</p> Source code in <code>bblib/utils.py</code> <pre><code>def get_fwhm_map_global_min(\n    lines: list, output_folder: str, label: str, pixel_step: int, plots_flag: bool\n) -&gt; tuple:\n    \"\"\"\n    Open FWHM grid search optmization plot, fit projections in both axis to get the point of maximum sharpness of the radial average.\n    # To rewrite.\n\n    Attributes:\n        lines (list): Output of grid search for FWHM optmization, each line should contain a dictionary contaning entries for xc, yc and fwhm_over_radius.\n\n    \"\"\"\n    n = int(math.sqrt(len(lines)))\n\n    merged_dict = {}\n    for dictionary in lines[:]:\n        for key, value in dictionary.items():\n            if key in merged_dict:\n                merged_dict[key].append(value)\n            else:\n                merged_dict[key] = [value]\n\n    # Create a figure with three subplots\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(10, 10))\n\n    # Extract x, y, and z from merged_dict\n\n    x = np.array(merged_dict[\"xc\"]).reshape((n, n))[0]\n    y = np.array(merged_dict[\"yc\"]).reshape((n, n))[:, 0]\n    z = np.array(merged_dict[\"fwhm\"], dtype=np.float64).reshape((n, n))\n    r = np.array(merged_dict[\"r_squared\"]).reshape((n, n))\n    z = np.nan_to_num(z)\n    r = np.nan_to_num(r)\n    pos1 = ax1.imshow(z, cmap=\"rainbow\")\n    step = 10\n    n = z.shape[0]\n\n    ax1.set_xticks(np.arange(0, n, step, dtype=int))\n    ax1.set_yticks(np.arange(0, n, step, dtype=int))\n\n    step = round(step * (abs(x[0] - x[1])), 1)\n    ax1.set_xticklabels(\n        np.arange(round(x[0], 1), round(x[-1] + step, 1), step, dtype=int), rotation=45\n    )\n    ax1.set_yticklabels(\n        np.arange(round(y[0], 1), round(y[-1] + step, 1), step, dtype=int)\n    )\n    ax1.set_ylabel(\"yc [px]\")\n    ax1.set_xlabel(\"xc [px]\")\n    ax1.set_title(\"FWHM\")\n\n    pos2 = ax2.imshow(r, cmap=\"rainbow\")\n    step = 10\n    n = z.shape[0]\n\n    ax2.set_xticks(np.arange(0, n, step, dtype=int))\n    ax2.set_yticks(np.arange(0, n, step, dtype=int))\n\n    step = round(step * (abs(x[0] - x[1])), 1)\n    ax2.set_xticklabels(\n        np.arange(round(x[0], 1), round(x[-1] + step, 1), step, dtype=int), rotation=45\n    )\n    ax2.set_yticklabels(\n        np.arange(round(y[0], 1), round(y[-1] + step, 1), step, dtype=int)\n    )\n\n    ax2.set_ylabel(\"yc [px]\")\n    ax2.set_xlabel(\"xc [px]\")\n    ax2.set_title(\"R\u00b2\")\n\n    proj_x = np.sum(z, axis=0) // n\n    x = np.arange(x[0], x[-1] + pixel_step, pixel_step)\n    index_x = np.unravel_index(np.argmin(proj_x, axis=None), proj_x.shape)\n    xc = x[index_x]\n    ax3.scatter(x, proj_x, color=\"b\")\n    ax3.scatter(xc, proj_x[index_x], color=\"r\", label=f\"xc: {xc}\")\n    ax3.set_ylabel(\"Average FWHM\")\n    ax3.set_xlabel(\"xc [px]\")\n    ax3.set_title(\"FWHM projection in x\")\n    ax3.legend()\n\n    proj_y = np.sum(z, axis=1) // n\n    x = np.arange(y[0], y[-1] + pixel_step, pixel_step)\n    index_y = np.unravel_index(np.argmin(proj_y, axis=None), proj_y.shape)\n    yc = x[index_y]\n    ax4.scatter(x, proj_y, color=\"b\")\n    ax4.scatter(yc, proj_y[index_y], color=\"r\", label=f\"yc: {yc}\")\n    ax4.set_ylabel(\"Average FWHM\")\n    ax4.set_xlabel(\"yc [px]\")\n    ax4.set_title(\"FWHM projection in y\")\n    ax4.legend()\n\n    fig.colorbar(pos1, ax=ax1, shrink=0.6)\n    fig.colorbar(pos2, ax=ax2, shrink=0.6)\n\n    if int(np.sum(proj_y)) == 0 or int(np.sum(proj_x)) == 0:\n        xc = -1\n        yc = -1\n    else:\n        if plots_flag:\n            plt.savefig(f\"{output_folder}/fwhm_map/{label}.png\")\n    plt.close()\n    return [np.round(xc, 0), np.round(yc, 0)]\n</code></pre>"},{"location":"reference/utils/#bblib.utils.make_polarization_array","title":"<code>make_polarization_array(pol, cox, coy, detdist, poldegree)</code>","text":"<p>Create the polarization array for horizontal polarization correction, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234 Acknowledgements: Oleksandr Yefanov, Marina Galchenkova</p> <p>Attributes:</p> Name Type Description <code>pol</code> <code>ndarray</code> <p>An array where polarization arra will be built based on its shape. Mask shape is the same size of data. Unvalid pixels (values containing 0) will be skipped from calculation and put 1.</p> <code>cox</code> <code>ndarray</code> <p>Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.</p> <code>coy</code> <code>ndarray</code> <p>Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.</p> <code>detdist</code> <code>float</code> <p>Detector distance from the sample in meters . The detctor distance will be transformed in pixel units based on Res defined as global parameter.</p> <code>poldegree</code> <code>float</code> <p>Polarization degree from [0,1]. The horizontal polarization at most synchrotrons sources, e.g DESY, p is 0.99.</p> <p>Returns:     pol (np.ndarray): Polarization array for polarization correction.</p> Source code in <code>bblib/utils.py</code> <pre><code>def make_polarization_array(\n    pol: np.ndarray, cox: np.ndarray, coy: np.ndarray, detdist: float, poldegree: float\n) -&gt; np.ndarray:\n    \"\"\"\n    Create the polarization array for horizontal polarization correction, version in Python. It is based on pMakePolarisationArray from https://github.com/galchenm/vdsCsPadMaskMaker/blob/main/new-versions/maskMakerGUI-v2.py#L234\n    Acknowledgements: Oleksandr Yefanov, Marina Galchenkova\n\n    Attributes:\n        pol (np.ndarray): An array where polarization arra will be built based on its shape. Mask shape is the same size of data. Unvalid pixels (values containing 0) will be skipped from calculation and put 1.\n        cox (np.ndarray): Array containg pixels coordinates in x (pixels) distance from the direct beam. It has same shape of data.\n        coy (np.ndarray): Array containg pixels coordinates in y (pixels) distance from the direct beam. It has same shape of data.\n        detdist (float): Detector distance from the sample in meters . The detctor distance will be transformed in pixel units based on Res defined as global parameter.\n        poldegree (float): Polarization degree from [0,1]. The horizontal polarization at most synchrotrons sources, e.g DESY, p is 0.99.\n    Returns:\n        pol (np.ndarray): Polarization array for polarization correction.\n    \"\"\"\n\n    z = detdist * np.ones(cox.shape[0])\n    valid = np.where(pol == 1)\n\n    pol[valid] = 1 - (\n        (poldegree * (cox[valid] ** 2) + (1 - poldegree) * (coy[valid] ** 2))\n        / (cox[valid] ** 2 + coy[valid] ** 2 + z[valid] ** 2)\n    )\n    pol[np.where(pol == 0)] = 1.0\n\n    return pol\n</code></pre>"},{"location":"reference/utils/#bblib.utils.mask_peaks","title":"<code>mask_peaks(mask, indexes, bragg, n)</code>","text":"<p>Gather coordinates of a box of 1x1 pixels around each point from the indexes list. Bragg flag indicates if the mask returned will contain only bragg peaks regions (bragg =1), no bragg peaks regions (bragg=0), or both (bragg =-1).</p> <p>Attributes:</p> Name Type Description <code>mask</code> <code>ndarray</code> <p>An array where mask will be built based on its shape. Mask shape is the same size of data.</p> <code>indexes</code> <code>tuple</code> <p>Bragg peaks coordinates, indexes[0] contains x-coordinates of Bragg peaks and indexes[1] the corresponding y-coordinates.</p> <code>bragg</code> <code>int</code> <p>Bragg flag, choose between return only peaks, only background or both (bypass masking of peaks).</p> <code>n</code> <code>int</code> <p>Number of pixels to build a 2*n box around the Bragg peaks.</p> <p>Returns:</p> Name Type Description <code>surrounding_mask</code> <code>ndarray</code> <p>Corresponding mask according to bragg flag choice. It contains zeros for unvalid pixels and one for valid pixels. Mask shape is the same size of data.</p> Source code in <code>bblib/utils.py</code> <pre><code>def mask_peaks(mask: np.ndarray, indexes: tuple, bragg: int, n: int) -&gt; np.ndarray:\n    \"\"\"\n    Gather coordinates of a box of 1x1 pixels around each point from the indexes list. Bragg flag indicates if the mask returned will contain only bragg peaks regions (bragg =1), no bragg peaks regions (bragg=0), or both (bragg =-1).\n\n    Attributes:\n        mask (np.ndarray): An array where mask will be built based on its shape. Mask shape is the same size of data.\n        indexes (tuple): Bragg peaks coordinates, indexes[0] contains x-coordinates of Bragg peaks and indexes[1] the corresponding y-coordinates.\n        bragg (int): Bragg flag, choose between return only peaks, only background or both (bypass masking of peaks).\n        n (int): Number of pixels to build a 2*n box around the Bragg peaks.\n\n    Returns:\n        surrounding_mask (np.ndarray): Corresponding mask according to bragg flag choice. It contains zeros for unvalid pixels and one for valid pixels. Mask shape is the same size of data.\n    \"\"\"\n    surrounding_positions = []\n    count = 0\n    for index in zip(indexes[0], indexes[1]):\n        row, col = index\n        for i in range(-n, n + 1):\n            for k in range(-n, n + 1):\n                surrounding_positions.append((row + i, col + k))\n        count += 1\n\n    # print(args.bragg)\n    if bragg == 1:\n        surrounding_mask = np.zeros_like(mask)\n        for pos in surrounding_positions:\n            row, col = pos\n            if 0 &lt;= row &lt; mask.shape[0] and 0 &lt;= col &lt; mask.shape[1]:\n                surrounding_mask[row, col] = 1\n    elif bragg == -1:\n        surrounding_mask = np.ones_like(mask)\n    else:\n        surrounding_mask = np.ones_like(mask)\n        for pos in surrounding_positions:\n            row, col = pos\n            if 0 &lt;= row &lt; mask.shape[0] and 0 &lt;= col &lt; mask.shape[1]:\n                surrounding_mask[row, col] = 0\n\n    return surrounding_mask\n</code></pre>"},{"location":"reference/utils/#bblib.utils.ring_mask","title":"<code>ring_mask(data, center, inner_radius, outer_radius)</code>","text":"<p>Make a  ring mask for the data</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>ndarray</code> <p>Image in which mask will be shaped</p> <code>center</code> <code>tuple</code> <p>(xc,yc)</p> <code>inner_radius</code> <code>int</code> <code>outer_radius</code> <code>int</code> <p>Returns:</p> Name Type Description <code>mask</code> <code>ndarray</code> <p>Mask array containg zeros (pixels to be masked) and ones (valid pixels).</p> Source code in <code>bblib/utils.py</code> <pre><code>def ring_mask(\n    data: np.ndarray, center: tuple, inner_radius: int, outer_radius: int\n) -&gt; np.ndarray:\n    \"\"\"\n    Make a  ring mask for the data\n\n    Attributes:\n        data (np.ndarray): Image in which mask will be shaped\n        center (tuple): (xc,yc)\n        inner_radius (int):\n        outer_radius (int):\n\n    Returns:\n        mask (np.ndarray): Mask array containg zeros (pixels to be masked) and ones (valid pixels).\n    \"\"\"\n\n    bin_size = bin\n    a = data.shape[0]\n    b = data.shape[1]\n    [X, Y] = np.meshgrid(np.arange(b) - center[0], np.arange(a) - center[1])\n    R = np.sqrt(np.square(X) + np.square(Y))\n    bin_size = outer_radius - inner_radius\n    return np.greater(R, outer_radius - bin_size) &amp; np.less(R, outer_radius + bin_size)\n</code></pre>"}]}